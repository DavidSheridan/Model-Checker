<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">

<script>
  (function() {
    Polymer({
      is: 'automata-parser-pegjs',

      properties: {

        /**
         * The PEGjs parser.
         * Used to create a parse tree that we can the interpret.
         */
        _parser: {
          type: Object,
          value: PEG_automataParser, // created in parser.js
          readOnly: true
        },

        /**
         * The Definitions map.
         */
        _definitionsMap: {
          type: Object,
          value: {}
        },

        /**
         * An array of arrays of nodes that need to be merged.
         */
        _nodesToMerge: {
          type: Array,
          value: []
        },

        /**
         * The next node ID to use.
         * Do not modify this field directly, instead use this._useNextNodeId()
         */
        _nextNodeId: Number,

        /**
         * The next edge ID to use.
         * Do not modify this field directly, instead use this._useNextEdgeId()
         */
        _nextEdgeId: Number
      },

      /**
       * A collections of nodes and edges.
       * @class
       */
      _Graph: function(nodes, edges, rootId){
        this.nodes = nodes || [];
        this.edges = edges || [];
        this.rootId = rootId;
      },

      /**
       * @class
       */
      _Node: function($this, extras){
        this.id = $this._useNextNodeId();
        this.label = this.id + '';
        this.extras = extras || {};
      },

      /**
       * @class
       */
      _Edge: function($this, from, to, label){
        this.id = $this._useNextEdgeId();
        this.from = from;
        this.to = to;
        this.label = label;
      },

      /**
       * Parse the code and return the automatas it defines.
       * @param {string} code The code to parse
       * @returns {Array} An array of automatas
       */
      parse: function(code){
        var pt = this._parser.parse(code);
        return this._interpretParseTree(pt);
      },

      /**
       * Reset the fields used by the interpreter methods.
       */
      _resetInterpreter: function(){
        this._nextNodeId = 0;
        this._nextEdgeId = 0;
        this._nodesToMerge = [];
      },

      /**
       * Interpret a parse tree generated by the parser and create an array of automatas from it.
       * @param {Array} parseTree A parse tree made by the parser
       * @returns {Array} An array of automatas
       */
      _interpretParseTree: function(parseTree){
        this._resetInterpreter();
        var automatas = [];

        parseTree.forEach(function(model){
          this._initialiseDefinitionMap(model.definitions);
        }.bind(this));

        // _interpretModel
        parseTree.forEach(function(model){
          automatas.push(this._interpretDefinitions(model.definitions));
        }.bind(this));

        return automatas;
      },

      /**
       * Initialise the definitions map with keys.
       * Each key is a name of a definition.
       */
      _initialiseDefinitionMap: function(definitions){
        this._definitionsMap = {};
        definitions.forEach(function(definition, index){
          var name = this._getNameFromNode(definition.name);
          // if(index == 0){
          //   label = name;
          // }

          if(this._definitionsMap[name]){
            console.error('Error: defined twice');
            return;
          }

          this._definitionsMap[name] = true;
        }.bind(this));
      },

      /**
       * Interpret the definitions defined in a parse tree.
       * @param {Array} definitions An array of definitions
       * @returns {Automata}
       */
      _interpretDefinitions: function(definitions){
        var label;
        var root = new this._Node(this, {startNode: true});
        var graph = new this._Graph([root], [], root.id);

        definitions.forEach(function(definition, index){
          var name = this._getNameFromNode(definition.name);
          if(index == 0){
            label = name;
          }

          var subgraph = this._interpretProcess(definition.process, root);
          graph = this._combineGraphs(root.id, graph, subgraph);

          while(this._nodesToMerge.length > 0){
            this._mergeNodes(graph, this._nodesToMerge.pop());
          }

          this._definitionsMap[name] = graph;
        }.bind(this));

        return {label: label, nodes: graph.nodes, edges: graph.edges};
      },

      /**
       * Interpret a process node.
       * @param {Object} process A process node (process nodes are abstract)
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretProcess: function(process, root){
        switch (process.type) {
          case 'sequence':  return this._interpretSequence(process, root);
          case 'choice':    return this._interpretChoice(process, root);
          case 'parallel':  return this._interpretParallel(process, root);
          case 'name':      return this._interpretName(process, root);
          case 'stop':      return this._interpretStop(process, root);
          case 'error':     return this._interpretError(process, root);
          default:
            console.error('Trying to interpret invalid process type "'+process.type+'"');
            break;
        }
      },

      /**
       * Interpret a sequence node.
       * @param {Object} sequence A sequence node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretSequence: function(sequence, root){
        var subgraph1;
        var fromNode;

        switch (sequence.from.type) {
          case 'name':
            var name = this._getNameFromNode(sequence.from);
            subgraph1 = this._definitionsMap[name];
            break;
          case 'action':
            var from = this._getActionFromNode(sequence.from);
            fromNode = new this._Node(this);
            var e = new this._Edge(this, root.id, fromNode.id, from);
            subgraph1 = new this._Graph([fromNode], [e], root.id);
            break;
          default:
            console.error('Trying to interpret invalid sequence from type "'+sequence.type+'"');
            break;
        }

        var subgraph2 = this._interpretProcess(sequence.to, fromNode);
        return this._combineGraphs(subgraph1.rootId, subgraph1, subgraph2);
      },

      /**
       * Interpret a choice node.
       * @param {Object} choice A choice node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretChoice: function(choice, root){
        var g1root = new this._Node(this);
        var g1 = this._interpretProcess(choice.option1, g1root);

        var g2root = new this._Node(this);
        var g2 = this._interpretProcess(choice.option2, g2root);

        var g0 = new this._Graph([g1root, g2root], [
            new this._Edge(this, root.id, g1root.id, undefined),
            new this._Edge(this, root.id, g2root.id, undefined)], root.id);

        return this._combineGraphs(g0.rootId, g0, g1, g2);
      },

      /**
       * Interpret a parallel node.
       * @param {Object} parallel A parallel node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretParallel: function(parallel, root){
        var graph = new this._Graph();
        return graph;
      },

      /**
       * Interpret a name node.
       * @param {Object} node A name node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {string}
       */
      _interpretName: function(node, root){
        var graph = this._definitionsMap[this._getNameFromNode(node)];
        this._markNodesToMerge(root.id, graph.rootId);
        return graph;
      },

      /**
       * Interpret a stop node.
       * @param {Object} node A stop node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretStop: function(node, root){
        var n = new this._Node(this);
        var e = new this._Edge(this, root.id, n.id, undefined);
        return new this._Graph([n], [e], root.id);
      },

      /**
       * Interpret an error node.
       * @param {Object} node A error node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretError: function(node, root){
        return this._interpretStop(node, root);
      },

      /**
       * Get the name from a name node.
       * @param {Object} node A name node
       * @returns {string}
       */
      _getNameFromNode: function(node){
        return node.name;
      },

      /**
       * Get the action from an action node.
       * @param {Object} node A action node
       * @returns {string}
       */
      _getActionFromNode: function(node){
        return node.action;
      },

      /**
       * Combine two or more graphs into one.
       * This functions assumes the graphs do not share any nodes or edges.
       * @param {Number} rootId The ID of the node to use as the root of the combined graph
       * @param {..._Graph} g A variable number of graphs to be combined
       * @return {_Graph} the combined graph
       */
      _combineGraphs: function(rootId, g){
        if(arguments.length < 3){ console.error('Not enough graphs given to combine');}

        var nodes = g.nodes,
            edges = g.edges;

        for(var i=2; i<arguments.length; i++){
          nodes = nodes.concat(arguments[i].nodes);
          edges = edges.concat(arguments[i].edges);
        }

        return new this._Graph(nodes, edges, rootId);
      },

      /**
       * Mark the given nodes as needing to be merged into one at a later point.
       * This method may be useful if some nodes need to be merge but they are currently in different graphs.
       * @param {...Number} nodeId A variable number of node ID to mark as needing to be merged later
       */
      _markNodesToMerge: function(nodeId){
        if(arguments.length < 2){ console.error('Not enough nodes given to mark');}
        this._nodesToMerge.push(arguments);
      },

      /**
       * Merge the given nodes in the given graph into a single node.
       * @param {_Graph} g The graph to conduct the merge with in
       * @param {Array} nodeIds An array of nodes to merge (specified by their IDs)
       */
      _mergeNodes: function(g, nodeIds){
        if(nodeIds.length < 2){ console.error('Not enough nodes given to merge');}

        // delete all the extra nodes (keep the first one)
        g.nodes = g.nodes.filter(function(node){
          for(var i=1; i<nodeIds.length; i++){
            if(node.id == nodeIds[i]){
              return false;
            }
          }
          return true;
        });

        // change all the edges the refer to a delete node to refer to the merge one
        g.edges.forEach(function(edge){
          for(var i=1; i<nodeIds.length; i++){
            if(edge.from == nodeIds[i]){
              edge.from = nodeIds[0];
            }
            if(edge.to == nodeIds[i]){
              edge.to = nodeIds[0];
            }
          }
        });
      },

      /**
       *
       */
      _relabelNodes: function(g){

      },

      /**
       * Create the next unique node ID and return the previous one.
       * @returns {Number} a unique node ID
       */
      _useNextNodeId: function(){
        return this._nextNodeId++;
      },

      /**
       * Create the next unique edge ID and return the previous one.
       * @returns {Number} a unique edge ID
       */
      _useNextEdgeId: function(){
        return this._nextEdgeId++;
      }

    });
  })();
</script>
