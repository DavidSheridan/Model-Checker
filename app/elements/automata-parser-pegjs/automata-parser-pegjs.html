<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">

<script>
  (function() {
    Polymer({
      is: 'automata-parser-pegjs',

      properties: {
        /**
         * The PEGjs parser
         */
        _parser: {
          type: Object,
          value: PEG_automataParser, // created in parser.js
          readOnly: true
        },

        /**
         * The Definitions map
         */
        _definitionsMap: {
          type: Object,
          value: {}
        },

        /**
         * The node map
         */
        _nodeMap: {
          type: Array,
          value: []
        },

        /**
         * The previously made node
         */
        _previousNode: Object,

        /**
         * The next node id to use.
         * Do not modify this field directly, instead use this._getNextNodeId()
         */
        _nextNodeId: Number,

        /**
         * The next edge id to use.
         * Do not modify this field directly, instead use this._getNextEdgeId()
         */
        _nextEdgeId: Number
      },

      /**
       * A collections of nodes and edges
       * @class
       */
      _Graph: function(nodes, edges){
        this.nodes = nodes || [];
        this.edges = edges || [];
      },

      /**
       * @class
       */
      _Node: function($this){
        this.id = $this._useNextNodeId();
        this.label = this.id + '';
        $this._previousNode = this;
      },

      /**
       * @class
       */
      _Edge: function($this, from, to, label){
        this.id = $this._useNextEdgeId();
        this.from = from;
        this.to = to;
        this.label = label;
      },

      /**
       * Parse the code and return the automatas it defined
       * @param {string} code The code to parse
       * @returns {Array} An array of automatas
       */
      parse: function(code){
        var pt = this._parser.parse(code);
        return this._interpretParseTree(pt);
      },

      /**
       * Interpret a parseTree generated by the parser and create an array of automatas from it
       * @param {Array} parseTree A parse tree made by the parser
       * @returns {Array} An array of automatas
       */
      _interpretParseTree: function(parseTree){
        this._definitionsMap = {};
        this._nextNodeId = 0;
        this._nextEdgeId = 0;
        this._nodeMap = [];
        var automatas = [];

        var $this = this;

        parseTree.forEach(function(model){
          $this._buildDefinitions(model.definitions);
        });

        parseTree.forEach(function(model){
          automatas.push($this._interpretDefinitions(model.definitions));
        });

        return automatas;
      },

      _buildDefinitions: function(definitions){
        var $this = this;
        definitions.forEach(function(definition, index){

          var name = $this._getNameFromNode(definition.name);
          // if(index == 0){
          //   label = name;
          // }

          if($this._definitionsMap[name]){
            console.error("Error: defined twice");
            return;
          }

          $this._definitionsMap[name] = true;

        });
      },

      /**
       * Interpret the definitions from a parseTree
       * @param {Array} definitions An array of definitions
       * @returns {Automata}
       */
      _interpretDefinitions: function(definitions){
        var label;
        var graph = new this._Graph();

        var $this = this;
        definitions.forEach(function(definition, index){
          graph.nodes.push(new $this._Node($this));

          var name = $this._getNameFromNode(definition.name);
          if(index == 0){
            label = name;
          }

          var subgraph = $this._interpretProcess(definition.process);
          graph = $this._combineGraphs(graph, subgraph);

          console.log(graph);

          while($this._nodeMap.length > 0){
            var nodes = $this._nodeMap.pop();
            $this._mergeNodes(graph, nodes[0], nodes[1]);
          }

          console.log(graph);

          $this._definitionsMap[name] = graph;
        });

        return {label: label, nodes: graph.nodes, edges: graph.edges};
      },

      /**
       * Interpret a process node
       * @param {Object} process A process node (process nodes are abstract)
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretProcess: function(process){
        switch (process.type) {
          case 'sequence':
            return this._interpretSequence(process);
            break;
          case 'choice':
            return this._interpretChoice(process);
            break;
          case 'parallel':
            return this._interpretParallel(process);
            break;
          case 'name':
            return this._interpretName(process);
            break;
          case 'stop':
            return this._interpretStop();
            break;
          case 'error':
            return this._interpretError();
            break;
        }
      },

      /**
       * Interpret a sequence node
       * @param {Object} sequence A sequence node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretSequence: function(sequence){

        var subgraph1;

        switch (sequence.from.type) {
          case 'name':

            var name = this._getNameFromNode(label);
            subgraph1 = this._definitionsMap[name];

            break;
          case 'action':

            var from = this._getActionFromNode(sequence.from);
            var previousNodeId = this._previousNode.id;
            var n = new this._Node(this);
            var e = new this._Edge(this, previousNodeId, n.id, from);
            subgraph1 = new this._Graph([n], [e]);

            break;
        }

        var subgraph2 = this._interpretProcess(sequence.to);

        return this._combineGraphs(subgraph1, subgraph2);
      },

      /**
       * Interpret a choice node
       * @param {Object} choice A choice node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretChoice: function(choice){

        var previousNodeId = this._previousNode.id;

        var g1, g2, g1Label, g2Label;

        if(choice.option1.type === "action" ){

          g1Label = this._getActionFromNode(choice.option1);
          var n = new this._Node(this);
          g1 = new this._Graph([n], []);

        }else{

          var n = new this._Node(this);
          var g1A = new this._Graph([n], []);
          var g1B = this._interpretProcess(choice.option1);

          g1 = this._combineGraphs(g1A, g1B);
        }

        if(choice.option2.type === "action" ){

          g2Label = this._getActionFromNode(choice.option2);
          var n = new this._Node(this);
          g2 = new this._Graph([n], []);

        }else{
          var n = new this._Node(this);
          var g2A = new this._Graph([n], []);
          var g2B = this._interpretProcess(choice.option2);

          g2 = this._combineGraphs(g2A, g2B);
        }

        var e1 = new this._Edge(this, previousNodeId, g1.nodes[0].id, g1Label);
        var e2 = new this._Edge(this, previousNodeId, g2.nodes[0].id, g2Label);
        var g0 = new this._Graph([], [e1, e2]);

        return this._combineGraphs(g0, g1, g2);
      },

      /**
       * Interpret a parallel node
       * @param {Object} parallel A parallel node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretParallel: function(parallel){
        var graph = new this._Graph();
        return graph;
      },

      /**
       * Interpret a name node
       * @param {Object} node A name node
       * @returns {string}
       */
      _interpretName: function(node){
        var graph = this._definitionsMap[this._getNameFromNode(node)];
        var previousNodeId = this._previousNode.id;
        var graphStartNodeId = graph.nodes[0].id;

        this._nodeMap.push([previousNodeId, graphStartNodeId]);

        return graph;
      },

      /**
       * Interpret a name node
       * @param {Object} node A name node
       * @returns {string}
       */
      _getNameFromNode: function(node){
        return node.name;
      },

      /**
       * Interpret an action node
       * @param {Object} node A action node
       * @returns {string}
       */
      _getActionFromNode: function(node){
        return node.action;
      },

      /**
       * Interpret a stop node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretStop: function(){
        var previousNodeId = this._previousNode.id;
        var n = new this._Node(this);
        var e = new this._Edge(this, previousNodeId, n.id, undefined);
        return new this._Graph([n], [e]);
      },

      /**
       * Interpret an error node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretError: function(){
        return this._interpretStop();
      },

      /**
       * Combine two or more graphs into one.
       * This functions assumes the graphs do not share any nodes or edges
       * @param {..._Graph} g A variable number of graphs to be combined
       * @return {_Graph} the combined graph
       */
      _combineGraphs: function(g){

        if(arguments.length < 2){ console.log("Why combining, when passing less than two graphs, man!");}

        var nodes = g.nodes,
            edges = g.edges;

        for(var i=1; i<arguments.length; i++){

          nodes = nodes.concat(arguments[i].nodes);
          edges = edges.concat(arguments[i].edges);

        }

        return new this._Graph(nodes, edges);
      },

      /**
       * Merge a node in place of another node within a graph.
       * Given a graph change all references of node1Id to node2Id and delete node2Id
       * @param {_Graph} g The graph to conduct the merge on
       * @param {Number} node1Id The node to be replaced
       * @param {Number} node2Id The node to replace with
       * @return {_Graph} the merged graph
       */
      _mergeNodes: function(g, node1Id, node2Id){

        g.nodes = g.nodes.filter(function(node){ return node.id != node1Id});

        g.edges.forEach(function(edge){
          if(edge.from === node1Id){
            edge.from = node2Id;
          }
          if(edge.to === node1Id){
            edge.to = node2Id;
          }
        });

        return g;

      },

      /**
       * Create the next unique node id and return the previous one
       * @returns {Number} a unique node id
       */
      _useNextNodeId: function(){
        return this._nextNodeId++;
      },

      /**
       * Create the next unique edge id and return the previous one
       * @returns {Number} a unique edge id
       */
      _useNextEdgeId: function(){
        return this._nextEdgeId++;
      }

    });
  })();
</script>
