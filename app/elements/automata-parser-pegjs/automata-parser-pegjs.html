<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">
<link rel="import" href="../imports/classes.html">

<script>
  // jshint -W106
  (function() {
    Polymer({
      is: 'automata-parser-pegjs',

      properties: {

        /**
         * The PEGjs parser.
         * Used to create a parse tree that we can the interpret.
         * @private
         */
        _parser: {
          type: Object,
          value: PEG.automataParser, // created in parser.js
          readOnly: true
        },

        /**
         * A Map of automaton names to their definition.
         * @private
         */
        _definitionsMap: {
          type: Object,
          readOnly: true
        },

        /**
         * An array of node id from the currently being built definition that need to merged.
         * @private
         */
        _nodeIdsMarkedToMerge: {
          type: Array,
          readOnly: true
        },

        /**
         * The next node ID to use.
         * Used by the Node class.
         * @private
         */
        _nextNodeId: {
          type: Number,
          readOnly: true
        },

        /**
         * The next edge ID to use.
         * Used by the Edge class.
         * @private
         */
        _nextEdgeId: {
          type: Number,
          readOnly: true
        },
      },

      /**
       * @private
       * @class
       * @param {Graph} graph The definition's graph
       */
      _Definition: function(graph){
        this.graph = graph;
        this.referenceMap = {}; // A map of automaton names to the first 'name' node that references it to have been processed
      },

      /**
       * Parse the code and return the automatas it defines.
       * @public
       * @param {string} code The code to parse
       * @returns {Automaton[]} Automata
       */
      parse: function(code){
          var pt = this._parser.parse(code);
          return this._interpretParseTree(pt);
      },

      /**
       * Reset the interpreter (reinitialise).
       * @private
       */
      _resetInterpreter: function(){
        this._set_nextNodeId(0);
        this._set_nextEdgeId(0);
        this._set_definitionsMap({});
        this._set_nodeIdsMarkedToMerge([]);
      },

      /**
       * Interpret a parse tree generated by the parser and create an array of automatas from it.
       * @private
       * @param {Array} parseTree A parse tree made by the parser
       * @returns {Array} An array of automatas
       */
      _interpretParseTree: function(parseTree){
        this._resetInterpreter();

        // _interpretModel
        parseTree.forEach(function(model){
          this._interpretDefinitions(model.definitions);
        }.bind(this));

        // returns whether or not there are still unprocessed references in any of the automata definitions.
        var unprocessedReferences = function(){
          for(var key in this._definitionsMap){
            for(var i=0; i<this._definitionsMap[key].graph.nodes.length; i++){
              if(this._definitionsMap[key].graph.nodes[i].extras.referenceUnprocessed){
                return true;
              }
            }
          }
          return false;
        }.bind(this);

        while(unprocessedReferences()){
          this._processSelfReferences();
          this._processNonselfReferences();
        }

        this._relabelNodes();

        return this._buildAutomataArray();
      },

      /**
       * Process any reference an automata definition make to itself by creating a cycle.
       * @private
       */
      _processSelfReferences: function(){
        var findAndProcess = function(node){
          if(node.extras.referenceUnprocessed && node.extras.references === key){
            delete node.extras.referenceUnprocessed;
            this._definitionsMap[key].graph.mergeNodes([this._definitionsMap[key].graph.rootNode.id, node.id]);
          }
        }.bind(this);

        for(var key in this._definitionsMap){
          this._definitionsMap[key].graph.nodes.forEach(findAndProcess);
        }
      },

      /**
       * Process any reference an automata definition makes to another definition by extending one onto the other.
       * @private
       */
      _processNonselfReferences: function(){
        var originalDefinitionsMapGraphs = {};
        var key;
        var findAndProcess = function(node){
          if(node.extras.referenceUnprocessed){
            // check that each reference noted references an actual definition
            if(this._definitionsMap[node.extras.references] === undefined){
              throw new InterpreterException('process "' + node.extras.references + '" referenced in "' + key + '" does not exist.');
            }

            var proccedReference = this._definitionsMap[key].referenceMap[node.extras.references];
            if(proccedReference && !proccedReference.extras.referenceUnprocessed){
              var g = this._definitionsMap[key].graph.deepClone();
              g.mergeNodes([node.id, proccedReference.id]);
              delete g.getNode(node.id).extras.referenceUnprocessed;
              this._definitionsMap[key].graph = g;
            }
            else{
              var g = originalDefinitionsMapGraphs[node.extras.references].deepClone();
              for(var ref in this._definitionsMap[node.extras.references].referenceMap){
                this._definitionsMap[key].referenceMap[ref] = this._definitionsMap[node.extras.references].referenceMap[ref];
              }
              var combined = this._definitionsMap[key].graph.combineWith(this._definitionsMap[key].graph.rootNode.id, g);
              delete combined.getNode(node.id).extras.referenceUnprocessed;
              combined.mergeNodes([node.id, g.rootNode.id]);
              if(this._definitionsMap[key].referenceMap[key]){
                combined.mergeNodes([combined.rootNode.id, this._definitionsMap[key].referenceMap[key].id]);
                delete this._definitionsMap[key].referenceMap[key];
              }
              this._definitionsMap[key].graph = combined;
              this._definitionsMap[key].referenceMap[node.extras.references] = node;
            }
          }
        }.bind(this);

        for(key in this._definitionsMap){
          originalDefinitionsMapGraphs[key] = this._definitionsMap[key].graph.deepClone();
        }

        for(key in this._definitionsMap){
          this._definitionsMap[key].graph.nodes.forEach(findAndProcess);
        }
      },

      /**
       * Takes all the automaton definitions and construct an array of automata.
       * @private
       * @returns {Automaton[]} Automata
       */
      _buildAutomataArray: function(){
        var automatas = [];
        for(var key in this._definitionsMap){
          automatas.push(new Automaton(key, this._definitionsMap[key].graph));
        }
        return automatas;
      },

      /**
       * Interpret the definitions defined in a parse tree.
       * @private
       * @param {Array} definitions An array of definitions
       */
      _interpretDefinitions: function(definitions){
        var label;
        var graph = new Graph();
        var root = graph.addNode(this._useNextNodeId());

        definitions.forEach(function(definition, index){
          var name = this._getNameFromNode(definition.name);
          if(index === 0){
            label = name;
          }

          //Check that the definition is not already recorded
          if(this._definitionsMap[label]){
            throw new InterpreterException('process "' + label + '" already defined.');
          }

          var subgraph = this._interpretProcess(definition.process, root, []);
          while(this._nodeIdsMarkedToMerge.length > 0){
            var nodeIds = this._nodeIdsMarkedToMerge.pop();
            subgraph.mergeNodes(nodeIds);
          }
          graph = graph.combineWith(root.id, subgraph);
        }.bind(this));

        this._definitionsMap[label] = new this._Definition(graph);
      },

      /**
       * Interpret a process node.
       * @private
       * @param {Object} process A process node (process nodes are abstract)
       * @param {Node} root The node to treat as the root in the subgraph being created
       * @returns {Graph} A subgraph of the overall automata definition
       */
      _interpretProcess: function(process, root, referenceMap){
        switch (process.type) {
          case 'sequence':  return this._interpretSequence(process, root, referenceMap);
          case 'choice':    return this._interpretChoice(process, root, referenceMap);
          case 'parallel':  return this._interpretParallel(process, root, referenceMap);
          case 'name':      return this._interpretName(process, root, referenceMap);
          case 'stop':      return this._interpretStop(process, root, referenceMap);
          case 'error':     return this._interpretError(process, root, referenceMap);
          default:
            console.error('Trying to interpret invalid process type "'+process.type+'"');
            break;
        }
      },

      /**
       * Interpret a sequence node.
       * @private
       * @param {Object} sequence A sequence node
       * @param {Node} root The node to treat as the root in the subgraph being created
       * @returns {Graph} A subgraph of the overall automata definition
       */
      _interpretSequence: function(sequence, root, referenceMap){
        var subgraph1;
        var fromNode;

        subgraph1 = new Graph();
        var fromNode = subgraph1.addNode(this._useNextNodeId());
        subgraph1.addEdge(this._useNextEdgeId(), root.id, fromNode.id, this._getActionFromNode(sequence.from));

        var subgraph2 = this._interpretProcess(sequence.to, fromNode, referenceMap);
        return subgraph1.combineWith(root.id, subgraph2);
      },

      /**
       * Interpret a choice node.
       * @private
       * @param {Object} choice A choice node
       * @param {Node} root The node to treat as the root in the subgraph being created
       * @returns {Graph} A subgraph of the overall automata definition
       */
      _interpretChoice: function(choice, root, referenceMap){
        var g1 = this._interpretProcess(choice.option1, root, referenceMap);
        var g2 = this._interpretProcess(choice.option2, root, referenceMap);
        return g1.combineWith(root.id, g2);
      },

      /**
       * Interpret a parallel node.
       * @private
       * @param {Object} parallel A parallel node
       * @param {Node} root The node to treat as the root in the subgraph being created
       * @returns {Graph} A subgraph of the overall automata definition
       */
      _interpretParallel: function(parallel, root, referenceMap){
        var graph = new Graph();
        return graph;
      },

      /**
       * Interpret a name node.
       * @private
       * @param {Object} node A name node
       * @param {Node} root The node to treat as the root in the subgraph being created
       * @returns {Graph} A subgraph of the overall automata definition
       */
      _interpretName: function(node, root, referenceMap){
        var name = this._getNameFromNode(node);
        if(referenceMap[name] === undefined){
          referenceMap[name] = root;
          root.extras.references = name;
          root.extras.referenceUnprocessed = true;
        }
        else{
          this._markNodeIdsToMerge(referenceMap[name].id, root.id);
        }
        return new Graph();
      },

      /**
       * Interpret a stop node.
       * @private
       * @param {Object} node A stop node
       * @param {Node} root The node to treat as the root in the subgraph being created
       * @returns {Graph} A subgraph of the overall automata definition
       */
      _interpretStop: function(node, root, referenceMap){
        root.extras.isTerminal = 'stop';
        return new Graph();
      },

      /**
       * Interpret an error node.
       * @private
       * @param {Object} node A error node
       * @param {Node} root The node to treat as the root in the subgraph being created
       * @returns {Graph} A subgraph of the overall automata definition
       */
      _interpretError: function(node, root, referenceMap){
        root.extras.isTerminal = 'error';
        return new Graph();
      },

      /**
       * Get the name from a name node.
       * @private
       * @param {Object} node A name node
       * @returns {string}
       */
      _getNameFromNode: function(node){
        return node.name;
      },

      /**
       * Get the action from an action node.
       * @private
       * @param {Object} node A action node
       * @returns {string}
       */
      _getActionFromNode: function(node){
        return node.action;
      },

      /**
       * Mark the given node ids as needing to be merged at a later point.
       * @private
       */
      _markNodeIdsToMerge: function(){
        if(arguments.length < 2){
          console.error('Not enough nodes given to merge');
        }
        this._nodeIdsMarkedToMerge.push(arguments);
      },

      /**
       * Relabel the nodes in each automata definition.
       * @private
       */
      _relabelNodes: function(){
        var label = 0;
        for(var key in this._definitionsMap){
          label = 0;
          var graph = this._definitionsMap[key].graph;
          var nodes = graph.nodes;
          var edges = graph.edges;
          var root;
          var nodeMap = {};
          var queue = [];

          for(var i in nodes){
            if(nodes[i].id === graph.rootNode.id){
              root = nodes[i];
              root.extras.startNode = true;
              nodeMap[root.id] = {node: nodes[i], distance: 0};
            }
            else{
              if(nodes[i].extras.references){
                nodes[i].id = this._definitionsMap[nodes[i].extras.references].graph.rootNode.id;
              }
              nodeMap[nodes[i].id] = {node: nodes[i], distance: undefined};
            }
          }
          queue.push(root);

          while (queue.length > 0){
            var u = queue.shift();
            if(nodeMap[u.id].node.label === undefined){
              u.label = (label++) + '';
            }
            for(var j in edges){
              if(u.id === edges[j].from &&
              !nodeMap[edges[j].to].distance &&
              u !== nodeMap[edges[j].to].node){
                queue.push(nodeMap[edges[j].to].node);
                nodeMap[edges[j].to].distance = nodeMap[u.id].distance + 1;
              }
            }
          }
        }
      },

      /**
       * Create the next unique node ID and return the previous one.
       * @private
       * @returns {Number} a unique node ID
       */
      _useNextNodeId: function(){
        var v = this._nextNodeId
        this._set_nextNodeId(v+1);
        return v;
      },

      /**
       * Create the next unique edge ID and return the previous one.
       * @private
       * @returns {Number} a unique edge ID
       */
      _useNextEdgeId: function(){
        var v = this._nextEdgeId;
        this._set_nextEdgeId(v+1);
        return v;
      }

    });
  })();
</script>
