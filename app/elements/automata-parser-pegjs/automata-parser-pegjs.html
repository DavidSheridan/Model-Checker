<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">

<script>
  (function() {
    Polymer({
      is: 'automata-parser-pegjs',

      properties: {

        /**
         * The PEGjs parser.
         * Used to create a parse tree that we can the interpret.
         */
        _parser: {
          type: Object,
          value: PEG.automataParser, // created in parser.js
          readOnly: true
        },

        /**
         * A Map of automata names to their definitions.
         */
        _definitionsMap:  Object,

        /**
         * The next node ID to use.
         * Used by the _Node class.
         */
        _nextNodeId: Number,

        /**
         * The next edge ID to use.
         * Used by the _Edge class.
         */
        _nextEdgeId: Number
      },

      /**
       * @class
       */
      _Automata: function(name, graph){
        this.name = name;
        this.graph = graph;
      },

      /**
       * A collections of nodes and edges.
       * @class
       */
      _Graph: function(nodes, edges, rootId){
        this.nodes = nodes || [];
        this.edges = edges || [];
        this.rootId = rootId;
      },

      /**
       * @class
       */
      _Node: function($this, extras){
        this.id = $this._useNextNodeId();
        this.label = this.id + '';
        this.extras = extras || {};
      },

      /**
       * @class
       */
      _Edge: function($this, from, to, label){
        this.id = $this._useNextEdgeId();
        this.from = from;
        this.to = to;
        this.label = label;
      },

      /**
       * Parse the code and return the automatas it defines.
       * @param {string} code The code to parse
       * @returns {Array} An array of automatas
       */
      parse: function(code){
        var pt = this._parser.parse(code);
        return this._interpretParseTree(pt);
      },

      /**
       * Reset the fields used by the interpreter methods.
       */
      _resetInterpreter: function(){
        this._nextNodeId = 0;
        this._nextEdgeId = 0;
        this._definitionsMap = {};
      },

      /**
       * Interpret a parse tree generated by the parser and create an array of automatas from it.
       * @param {Array} parseTree A parse tree made by the parser
       * @returns {Array} An array of automatas
       */
      _interpretParseTree: function(parseTree){
        this._resetInterpreter();

        // _interpretModel
        parseTree.forEach(function(model){
          this._interpretDefinitions(model.definitions);
        }.bind(this));

        // returns whether or not there are still unprocessed references in any of the automata definitions.
        var unprocessedReferences = function(){
          for(var key in this._definitionsMap){
            for(var i=0; i<this._definitionsMap[key].nodes.length; i++){
              if(this._definitionsMap[key].nodes[i].extras.referenceUnprocessed){
                return true;
              }
            }
          }
          return false;
        }.bind(this);

        do{
          this._processSelfReferences();
          this._processNonselfReferences();
        } while(unprocessedReferences());

        this._relabelNodes();

        return this._buildAutomataArray();
      },

      /**
       * Process any reference an automata definition make to itself by creating a cycle.
       */
      _processSelfReferences: function(){
        var findAndProcess = function(node){
          if(node.extras.references === key){
            // delete node.extras.references; // not much point in a node keeping a references to itself
            this._mergeNodes(this._definitionsMap[key], [this._definitionsMap[key].rootId, node.id]);
          }
        }.bind(this);

        for(var key in this._definitionsMap){
          this._definitionsMap[key].nodes.forEach(findAndProcess);
        }
      },

      /**
       * Process any reference an automata definition makes to another definition by extending one onto the other.
       */
      _processNonselfReferences: function(){
        var originalDefinitionsMap = {};

        var findAndProcess = function(node){
          if(node.extras.referenceUnprocessed){
            var g = originalDefinitionsMap[node.extras.references];
            var subgraph = this._cloneGraph(g);
            var combined = this._combineGraphs(this._definitionsMap[key].rootId, this._definitionsMap[key], subgraph);
            this._mergeNodes(combined, [node.id, subgraph.rootId]);
            this._definitionsMap[key] = combined;
          }
        }.bind(this);

        var key;
        for(key in this._definitionsMap){
          originalDefinitionsMap[key] = this._definitionsMap[key];
        }

        for(key in this._definitionsMap){
          this._definitionsMap[key].nodes.forEach(findAndProcess);
        }
      },

      /**
       * Takes all the automata definitions and construct an array of Automata.
       * @returns {Array} An array of automatas
       */
      _buildAutomataArray: function(){
        var automatas = [];
        for(var key in this._definitionsMap){
          automatas.push(new this._Automata(key, this._definitionsMap[key]));
        }
        return automatas;
      },

      /**
       * Interpret the definitions defined in a parse tree.
       * @param {Array} definitions An array of definitions
       */
      _interpretDefinitions: function(definitions){
        var label;
        var root = new this._Node(this);
        var graph = new this._Graph([root], [], root.id);

        definitions.forEach(function(definition, index){
          var name = this._getNameFromNode(definition.name);
          if(index === 0){
            label = name;
          }

          var subgraph = this._interpretProcess(definition.process, root);
          graph = this._combineGraphs(root.id, graph, subgraph);
        }.bind(this));

        this._definitionsMap[label] = graph;
      },

      /**
       * Interpret a process node.
       * @param {Object} process A process node (process nodes are abstract)
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata definition
       */
      _interpretProcess: function(process, root){
        switch (process.type) {
          case 'sequence':  return this._interpretSequence(process, root);
          case 'choice':    return this._interpretChoice(process, root);
          case 'parallel':  return this._interpretParallel(process, root);
          case 'name':      return this._interpretName(process, root);
          case 'stop':      return this._interpretStop(process, root);
          case 'error':     return this._interpretError(process, root);
          default:
            console.error('Trying to interpret invalid process type "'+process.type+'"');
            break;
        }
      },

      /**
       * Interpret a sequence node.
       * @param {Object} sequence A sequence node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata definition
       */
      _interpretSequence: function(sequence, root){
        var subgraph1;
        var fromNode;

        var from = this._getActionFromNode(sequence.from);
        fromNode = new this._Node(this);
        var e = new this._Edge(this, root.id, fromNode.id, from);
        subgraph1 = new this._Graph([fromNode], [e], root.id);

        var subgraph2 = this._interpretProcess(sequence.to, fromNode);
        return this._combineGraphs(subgraph1.rootId, subgraph1, subgraph2);
      },

      /**
       * Interpret a choice node.
       * @param {Object} choice A choice node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata definition
       */
      _interpretChoice: function(choice, root){
        var g1 = this._interpretProcess(choice.option1, root);
        var g2 = this._interpretProcess(choice.option2, root);
        return this._combineGraphs(root.id, g1, g2);
      },

      /**
       * Interpret a parallel node.
       * @param {Object} parallel A parallel node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata definition
       */
      _interpretParallel: function(parallel, root){
        var graph = new this._Graph();
        return graph;
      },

      /**
       * Interpret a name node.
       * @param {Object} node A name node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata definition
       */
      _interpretName: function(node, root){
        root.extras.references = this._getNameFromNode(node);
        root.extras.referenceUnprocessed = true;
        return new this._Graph();
      },

      /**
       * Interpret a stop node.
       * @param {Object} node A stop node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata definition
       */
      _interpretStop: function(node, root){
        root.extras.isTerminal = 'stop';
        return new this._Graph();
      },

      /**
       * Interpret an error node.
       * @param {Object} node A error node
       * @param {_Node} root The node to treat as the root in the subgraph being created
       * @returns {_Graph} A subgraph of the overall automata definition
       */
      _interpretError: function(node, root){
        root.extras.isTerminal = 'error';
        return new this._Graph();
      },

      /**
       * Get the name from a name node.
       * @param {Object} node A name node
       * @returns {string}
       */
      _getNameFromNode: function(node){
        return node.name;
      },

      /**
       * Get the action from an action node.
       * @param {Object} node A action node
       * @returns {string}
       */
      _getActionFromNode: function(node){
        return node.action;
      },

      /**
       * Combine two or more graphs into one.
       * This functions assumes the graphs do not share any nodes or edges.
       * @param {Number} rootId The ID of the node to use as the root of the combined graph
       * @param {..._Graph} g A variable number of graphs to be combined
       * @returns {_Graph} the combined graph
       */
      _combineGraphs: function(rootId, g){
        if(arguments.length < 3){ console.error('Not enough graphs given to combine');}

        var nodes = g.nodes,
            edges = g.edges;

        for(var i=2; i<arguments.length; i++){
          nodes = nodes.concat(arguments[i].nodes);
          edges = edges.concat(arguments[i].edges);
        }

        return new this._Graph(nodes, edges, rootId);
      },

      /**
       * Create a deep clone of the given graph.
       * The clone will contain new nodes and edges that have difference ids from the original.
       * @param {_Graph} g The graph to clone
       * @returns {_Graph} The clone
       */
      _cloneGraph: function(g){
        var nodes = [];
        var edges = [];
        var nodeIdMapping = {};

        g.nodes.forEach(function(node){
          var n = new this._Node(this, node.extras);
          nodes.push(n);
          nodeIdMapping[node.id] = n.id;
        }.bind(this));

        g.edges.forEach(function(edge){
          edges.push(new this._Edge(this, nodeIdMapping[edge.from], nodeIdMapping[edge.to], edge.label));
        }.bind(this));

        return new this._Graph(nodes, edges, nodeIdMapping[g.rootId]);
      },

      /**
       * Merge the given nodes in the given graph into a single node.
       * @param {_Graph} g The graph to conduct the merge with in
       * @param {Array} nodeIds An array of nodes to merge (specified by their IDs)
       */
      _mergeNodes: function(g, nodeIds){
        if(nodeIds.length < 2){ console.error('Not enough nodes given to merge');}

        var extras = {};
        var mergedNode;

        //for every node in the graph
        g.nodes = g.nodes.filter(function(node){
          //check the node against each id marked to be merged
          for(var i=0; i<nodeIds.length; i++){
            //check if the current node needs to be merged
            if(node.id === nodeIds[i]){
              //check if the node has extras not to do with being unprocessed
              for(var key in node.extras){
                if(key !== 'referenceUnprocessed'){
                  //if it it doesn't save the key for the merged node
                  extras[key] = node.extras[key];
                }
              }

              //if it's the first node
              if(i===0){
                //save it is as the mergedNode
                mergedNode = node;
                //save the node
                return true;
              }

              //the id matches, and it's not the first node so get rid of the node
              return false;
            }
          }

          //the node isn't identified to be merged so save it
          return true;
        });

        //pass the saved extras to the merged node
        mergedNode.extras = extras;

        // change all the edges the refer to a delete node to refer to the merge one
        g.edges.forEach(function(edge){
          for(var i=1; i<nodeIds.length; i++){
            if(edge.from === nodeIds[i]){
              edge.from = nodeIds[0];
            }
            if(edge.to === nodeIds[i]){
              edge.to = nodeIds[0];
            }
          }
        });
      },

      /**
       * Relabel the nodes in each automata definition.
       */
      _relabelNodes: function(){
        var label = 0;
        var findAndRelabel = function(node){
          node.label = (label++) + '';
          if(this._definitionsMap[key].rootId === node.id){
            node.extras.startNode = true;
          }
        }.bind(this);

        for(var key in this._definitionsMap){
          label = 0;
          this._definitionsMap[key].nodes.forEach(findAndRelabel);
        }
      },

      /**
       * Create the next unique node ID and return the previous one.
       * @returns {Number} a unique node ID
       */
      _useNextNodeId: function(){
        return this._nextNodeId++;
      },

      /**
       * Create the next unique edge ID and return the previous one.
       * @returns {Number} a unique edge ID
       */
      _useNextEdgeId: function(){
        return this._nextEdgeId++;
      }

    });
  })();
</script>
