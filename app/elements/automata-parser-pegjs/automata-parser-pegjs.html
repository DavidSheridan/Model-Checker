<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">

<script>
  (function() {
    Polymer({
      is: 'automata-parser-pegjs',

      properties: {
        /**
         * The PEGjs parser
         */
        parser: {
          type: Object,
          value: PEG_automataParser, // created in parser.js
          readOnly: true
        },

        /**
         * The previously made node
         */
        _previousNode: Object,

        /**
         * The next node id to use.
         * Do not modify this field directly, instead use this._getNextNodeId()
         */
        _nextNodeId: Number,

        /**
         * The next edge id to use.
         * Do not modify this field directly, instead use this._getNextEdgeId()
         */
        _nextEdgeId: Number
      },

      /**
       * A collections of nodes and edges
       * @class
       */
      _Graph: function(nodes, edges){
        this.nodes = nodes || [];
        this.edges = edges || [];
      },

      /**
       * @class
       */
      _Node: function($this){
        this.id = $this._useNextNodeId();
        this.label = this.id + '';
        $this._previousNode = this;
      },

      /**
       * @class
       */
      _Edge: function($this, from, to, label){
        this.id = $this._useNextEdgeId();
        this.from = from;
        this.to = to;
        this.label = label;
      },

      /**
       * Parse the code and return the automatas it defined
       * @param {string} code The code to parse
       * @returns {Array} An array of automatas
       */
      parse: function(code){
        var pt = this.parser.parse(code);
        return this._interpretParseTree(pt);
      },

      /**
       * Interpret a parseTree generated by the parser and create an array of automatas from it
       * @param {Array} parseTree A parse tree made by the parser
       * @returns {Array} An array of automatas
       */
      _interpretParseTree: function(parseTree){
        var automatas = [];

        var $this = this;
        parseTree.forEach(function(model){
          automatas.push($this._interpretDefinitions(model.definitions));
        });

        return automatas;
      },

      /**
       * Interpret the definitions from a parseTree
       * @param {Array} definitions An array of definitions
       * @returns {Automata}
       */
      _interpretDefinitions: function(definitions){
        this._nextNodeId = 0;
        this._nextEdgeId = 0;
        var label;
        var graph = new this._Graph();

        var $this = this;
        definitions.forEach(function(definition, index){
          graph.nodes.push(new $this._Node($this));

          var name = $this._interpretName(definition.name);
          if(index == 0){
            label = name;
          }

          var subgraph = $this._interpretProcess(definition.process);
          graph = $this._combineGraphs(graph, subgraph);
        });

        return {label: label, nodes: graph.nodes, edges: graph.edges};
      },

      /**
       * Interpret a process node
       * @param {Object} process A process node (process nodes are abstract)
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretProcess: function(process){
        switch (process.type) {
          case 'sequence':
            return this._interpretSequence(process);
            break;
          case 'choice':
            return this._interpretChoice(process);
            break;
          case 'parallel':
            return this._interpretParallel(process);
            break;
          case 'stop':
            return this._interpretStop();
            break;
          case 'error':
            return this._interpretError();
            break;
        }
      },

      /**
       * Interpret a sequence node
       * @param {Object} sequence A sequence node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretSequence: function(sequence){
        var from = this._interpretLabel(sequence.from);

        var previousNodeId = this._previousNode.id;
        var n = new this._Node(this);
        var e = new this._Edge(this, previousNodeId, n.id, from);
        var subgraph1 = new this._Graph([n], [e]);

        var subgraph2 = this._interpretProcess(sequence.to);

        return this._combineGraphs(subgraph1, subgraph2);
      },

      /**
       * Interpret a choice node
       * @param {Object} choice A choice node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretChoice: function(choice){
        var graph = new this._Graph();
        return graph;
      },

      /**
       * Interpret a parallel node
       * @param {Object} parallel A parallel node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretParallel: function(parallel){
        var graph = new this._Graph();
        return graph;
      },

      /**
       * Interpret a label node
       * @param {Object} label A label node (label nodes are abstract)
       * @returns {string}
       */
      _interpretLabel: function(label){
        switch (label.type) {
          case 'name':
            return this._interpretName(label);
            break;
          case 'action':
            return this._interpretAction(label);
            break;
        }
      },

      /**
       * Interpret a name node
       * @param {Object} node A name node
       * @returns {string}
       */
      _interpretName: function(node){
        return node.name;
      },

      /**
       * Interpret an action node
       * @param {Object} node A action node
       * @returns {string}
       */
      _interpretAction: function(node){
        return node.action;
      },

      /**
       * Interpret a stop node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretStop: function(){
        var previousNodeId = this._previousNode.id;
        var n = new this._Node(this);
        var e = new this._Edge(this, previousNodeId, n.id, undefined);
        return new this._Graph([n], [e]);
      },

      /**
       * Interpret an error node
       * @returns {_Graph} A subgraph of the overall automata
       */
      _interpretError: function(){
        return this._interpretStop();
      },

      /**
       * Combine two graphs into one.
       * This functions assumes the two graphs do not share any nodes or edges
       * @param {_Graph} g1
       * @param {_Graph} g2
       * @return {_Graph} the combined graph
       */
      _combineGraphs: function(g1, g2){
        return new this._Graph(g1.nodes.concat(g2.nodes), g1.edges.concat(g2.edges));
      },

      /**
       * Create the next unique node id and return the previous one
       * @returns {Number} a unique node id
       */
      _useNextNodeId: function(){
        return this._nextNodeId++;
      },

      /**
       * Create the next unique edge id and return the previous one
       * @returns {Number} a unique edge id
       */
      _useNextEdgeId: function(){
        return this._nextEdgeId++;
      }

    });
  })();
</script>
