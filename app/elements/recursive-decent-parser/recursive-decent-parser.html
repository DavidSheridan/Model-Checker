<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../imports/lexer.html">

<script>
  (function() {
    Polymer({
      is: 'recursive-decent-parser',

      properties: {
        
        _lexer: {
          type: Object,
          value: null
        },

        parseTreeNodes: {
          type: Object,
          readOnly: true,
          value: function(){
            function Node() {};
            Node.prototype.GlobalNode   = function(model, global){  this.model = model;   this.global = global; };
            Node.prototype.ModelNode    = function(def, model){     this.def = def;       this.model = model; };
            Node.prototype.DefNode      = function(name, pro){      this.name = name;     this.process = pro; };
            Node.prototype.ProcessNode  = function(child){          this.child = child; };
            Node.prototype.SequenceNode = function(lab, pro){       this.label = lab;     this.process = pro; };
            Node.prototype.ChoiceNode   = function(pro1, pro2){     this.process1 = pro1; this.process2 = pro2; };
            Node.prototype.ParallelNode = function(pro1, pro2){     this.process1 = pro1; this.process2 = pro2; };
            Node.prototype.LabelNode    = function(lab){            this.label = lab; };
            Node.prototype.NameNode     = function(lit){            this.literal = lit; };
            Node.prototype.ActionNode   = function(lit){            this.literal = lit; };
            Node.prototype.StopNode     = function(){};
            return new Node();
          }
        }

      },

      parse: function(code){
        this._lexer = new Lexer(code);
        var nextToken = this._lexer.next();
        return this._parseGlobals(nextToken);
      },

      _parseGlobals: function(token){
        var m = this._parseModel(token);
        var g;
        if(!this._gobble('ENDFILE', true)){
          g = this._parseGlobals();
        }
        return new this.parseTreeNodes.GlobalNode(m, g);
      },

      _parseModel: function(token){
        var d = this._parseDef(token);
        if(this._gobble('END', true)){
          return new this.parseTreeNodes.ModelNode(d);
        }
        else if(this._gobble('COMMA', true)){
          var nextToken = this._lexer.next();
          var m = this._parseModel(nextToken);
          return new this.parseTreeNodes.ModelNode(d, m);
        }
        throw new this.SyntaxError('Expecting \'.\' or \',\'');
      },

      _parseDef: function(token){
        var n = this._parseName(token);
        if(this._gobble('=', false)){
          var nextToken = this._lexer.next();
          var p = _parseProcess(nextToken);
          return new this.parseTreeNodes.DefNode(n, p);
        }
        throw new this.SyntaxError('Expecting \'=\'');
      },

      _parseProcess: function(token){
        if(token.type == 'LBRACK', true){
          var nextToken = this._lexer.next();
          var p = this._parseProcess(nextToken);
          if(!this._gobble('RBRACK', true)){throw new this.SyntaxError('Expecting \')\'');}
          return new this.parseTreeNodes.ProcessNode(p);
        }
        var r;
        if(r = this._parseStop(token)){return new this.parseTreeNodes.ProcessNode(r);}
        if(r = this._parseSequence(token)){return new this.parseTreeNodes.ProcessNode(r);}
        if(r = this._parseChoice(token)){return new this.parseTreeNodes.ProcessNode(r);}
        if(r = this._parseParallel(token)){return new this.parseTreeNodes.ProcessNode(r);}
        if(r = this._parseName(token)){return new this.parseTreeNodes.ProcessNode(r);}
        throw new this.SyntaxError('Unexpected Token ('+token+')');}
      },

      _parseSequence: function(token){
        var l;
        if(!l = this._parseLabel(token)){
          return null;
        }       
        if(!this._gobble('SEQUENCE', true)){
          this._ungobble();
          return null;
        } 
        var p = this._parseProcess();
        return new this.parseTreeNodes.SequenceNode(l, p);
      },

      _parseChoice: function(token){
        var p1;
        if(!p1 = this._parseProcess(token)){
          return null;
        }       
        if(!this._gobble('CHOICE', true)){
          this._ungobble();
          return null;
        } 
        var p2 = this._parseProcess();
        return new this.parseTreeNodes.ChoiceNode(p1, p2);
      },

      _parseParallel: function(token){
        var p1;
        if(!p1 = this._parseProcess(token)){
          return null
        }       
        if(!this._gobble('PARALLEL', true)){
          this._ungobble();
          return null;
        } 
        var p2 = this._parseProcess();
        return new this.parseTreeNodes.ParallelNode(p1, p2);
      },

      _parseLabel: function(token){
        var r;
        if(r = this._parseName()){return new this.parseTreeNodes.LabelNode(r);}
        if(r = this._parseAction()){return new this.parseTreeNodes.LabelNode(r);}
        throw new this.SyntaxError('Inavlid label');
      },

      _parseName: function(token){
        if(token.type == 'NAME'){
          return new this.parseTreeNodes.SequenceNode(token.text);
        }
        return null;
      },

      _parseAction: function(token){
        if(token.type == 'ACTION'){
          return new this.parseTreeNodes.ActionNode(token.text);
        }
        return null;
      },

      _parseStop: function(token){
        if(token.type == 'STOP'){
          return new this.parseTreeNodes.StopNode();
        }
        return null;
      },

      /**
       *This helper method checks the next token out of the lexer
       *and compares it with the given parameter, if they are the same
       *it consumes it and returns true, returns false.
       */
      _gobble: function(token, byTokenType){
        if((!byTokenType && this._lexer.peek().text == token)
        || ( byTokenType && this._lexer.peek().type == token)){
          this._lexer.next();
          return true;
        }
        else{
          return false;
        }
      },

      _ungobble: function(){
        if(this._lexer.hasPrev()){
          return this._lexer.prev();
        }
        else{
          return false;
        }
      },

      /**
       * JS Doc
       */
      ready: function(){

      },

       /**
       * An object to be thrown
       */
      SyntaxError: function(msg){
        this.message = msg;
      }


    });
  })();
</script>
