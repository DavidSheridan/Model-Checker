<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../imports/lexer.html">

<script>
  (function() {
    Polymer({
      is: 'automata-parser',

      properties: {

        /**
         * The code to be parsed
         */
        code: {
           type: String,
           value: ''
        },

         /**
          * The index we are up to
          * Used in the parsing process
          */
        _index: {
           type: Number,
           value: 0
         },

        _nodes: {
          type: Array,
          value: []
         },

        _edges: {
          type: Array,
          value: []
         },

         _currentEdge: {
          type: Object,
          value: null
         },

         _currentState: {
          type: String,
          value: ''
         },

        _variableName: {
          type: String,
          value: ''
        },

        _lexer: {
          type: Object.
          value: null
        },

        //[{Label, Nodes, Edges}]
        variableList: {
          type: Array,
          value: []
        },

        _state: {
          type: Object,
          value: function(){
            return {
              ready: 'ready',       //First case. Must be a define first.
              hasEdge: 'hasEdge', //Has an edge saved, if another label comes in prior to a transition, throws error.
              inSequence: 'inSequence', //The user has specified an edge followed by a sequence token, awaiting another label.
              firstLabel: 'firstLabel', //The first label has been declared the next token should be a define.
              waiting: 'waiting'
            }
          }
        }
      },

      /**
       * Parse the code
       *
       * @return {array} a token array
       * @throws {this.SyntaxError} Code must be valid
       */
      parse: function(){

        this._lexer = new Lexer(this.code);

        //Is this what node we are entering in to our sequence????
        this._index = 0;
        this._nodes=[];
        this._edges=[];
        this._currentEdge = null;


        //Maybe we should just have an array of edges seeing as node information is stored in an edge?

        this._currentState = this._state.ready;

        while(this._lexer.hasNext()){

          var token = lexer.next();

          if(token.type == 'LABEL'){
            this._parseLabel(token.text);
          }else if(token.type == 'SEQUENCE'){
            this._parseSequence();
          }else if(token.type == 'DEFINE'){
              this._parseDefine();
          }else if(token.type == 'LBRACK'){
            this._parseLbrack();
          }else if(token.type == 'RBRACK'){
            this._parseRbrack();
          }else if(token.type == 'LSQBRACK'){
            this._parseLsqbrack();
          }else if(token.type == 'RSQBRACK'){
            this._parseRsqbrack();
          }else if(token.type == 'ZERO_MANY'){
            this._parseZero_many();
          }else if(token.type == 'ONE_MANY'){
            this._parseOne_many();
          }else if(token.type == 'OR'){
            this._parseOr();
          }else if(token.type == 'PARALLEL'){
            this._parseParallel();
          }else if(token.type == 'OPTIONAL'){
            this._parseOptional();
          }else if(token.type == 'ENDFILE'){
            this._parseEndfile();
          }else if(token.type == 'END'){
            this._parseEnd();
          }else if(token.type == 'EMPTY'){
            this._parseEmpty();
          }else if(token.type == 'UNKNOWN'){
            this._parseUnkown();
          }

        }

        //result.push(this._automataParseNode());
        //result.push(this._automataParseOperation());
        //result.push(this._automataParseNode());

        //return result;

        //var returnObj = {};

        //returnObj.varname = {nodes: this._nodes, edges: this._edges};
        //returnObj.varname2 = {nodes: this._nodes, edges: this._edges};

        //return returnObj;
        return this.variableList;
      },

      _expectState: function(state){
        if(this._currentState != state){
          throw new this.SyntaxError('State Error: Expected state(' + state + '), differed from current state,(' + this._currentState + ').');
          return false;
        }
        return true;
      },

      _gobble: function(token){
        if(this._lexer.peek() == token){
          this._lexer.next();
          return true;
        }else{
          throw new this.SyntaxError('Syntax Error: Expected: (' + token + '), found: (' + this._lexer.peek() ').');
          return false;
        }
      },

      _parseEnd: function(){        
        if(_expectState(this._state.waiting)){
          var tempVariable = {label: this._variableName, nodes: this._nodes, edges: this._edges};
          this.variableList.push(tempVariable);
          this._nodes = [];
          this._edges = [];
          this._currentState = this._state.ready;          
        }
      },


      _parseLabel: function(text){
        if(this._currentState == this._state.ready){
          this._variableName = text;
          if(_gobble('=')){
            this._currentState = this._state.waiting;
          }
        }else if(this._currentState == this._state.inSequence){
          var from = this._currentEdge.to;
          var e = new this._Edge(from, this._createNode(), text);
          this._currentEdge = e;
          this._edges.push(e);
        }else if(this._currentState == this._state.waiting){
          var e = new this._Edge(this._createNode(), this._createNode(), text);
          this._currentEdge = e;
          this._edges.push(e);
          this._currentState = this._state.hasEdge;
        }else if(this._currentState == this._state.hasLabel){
          throw new this.SyntaxError('Syntax Error at char '+this._index+': multiple states without a transition.'); //Bad error message?
        }
        else{
          throw new this.SyntaxError('Syntax Error at char '+this._index+': Parsing a Label but in an unknown state: '+this._currentState+'. See admininistrator for help.');
        }
      },

      _parseSequence: function(){
        if(this._currentState == this._state.hasEdge){
              this._currentState = this._state.inSequence;
            }else{
              throw new this.SyntaxError('Syntax Error at char '+this._index+': Specified a sequence without a prior Label.');
            }

      },

  
      /**
       * Parse a node
       *
       * @return {string} The node's nametoke
       */

       //Are we going to use this
      _automataParseNode: function(){
        var initIndex = this._index;
        var reg = /[a-zA-Z][a-zA-Z0-9]*/g;
        var node, nextNode;
        while(reg.test(nextNode = this.code.substring(initIndex, this._index + 1))){
          node = nextNode;
          this._index++;
        }
        return node;
      },

      /**
       * Parse an operation
       *
       * @return {string} The operation
       */
      _automataParseOperation: function(){
        var op;
        if((op = '->') == this.code.substring(this._index, this._index+2)){
          this._index += op.length;
          return op;
        }
        throw new this.SyntaxError('Syntax Error at char '+this._index+': couldn\'t parse operation.');
      },

      _createNode: function(){
        var n = new this._Node(this._index++);
        this._nodes.push(n);
        return n;
      },

      _checkLabels: function(label){
        var present = false;
        for(var i = 0; i < this._index; i++){
          if(_nodes[i].label == label){
            present = true;
            break;
          }
        }
        return present;
      },
      /**
       * The Node class
       */
      _Node: function(i){
        this.label = i + '';
        this.id = i;
      },

      /**
       * The Edge class
       */
      _Edge: function(from, to, label){
        this.from = from;
        this.to = to;
        this.label = label;
      },

      /**
       * An object to be thrown
       */
      SyntaxError: function(msg){
        this.message = msg;
      }

    });
  })();
</script>
