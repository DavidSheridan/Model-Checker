<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">
<link rel="import" href="../imports/graph.html">
<link rel="import" href="../imports/automaton.html">

<script>
// jshint -W098
(function() {
  Polymer({
    is: 'automata-parser',
    properties: {
      /**
       * The PEGjs parser.
       * Used to create a parse tree that we can the interpret.
       *
       * @private
       */
      _parser: {
        type: Object,
        value: PEG.automataParser, // created in parser.js
        readOnly: true
      },
      /**
       * A Map of automaton names to their definition.
       *
       * @private
       */
      _definitionsMap: {
        type: Object,
        readOnly: true
      },
      /**
       * The next node ID to use.
       *
       * @private
       */
      _nextNodeId: {
        type: Number,
        readOnly: true
      },
      /**
       * The next edge ID to use.
       *
       * @private
       */
      _nextEdgeId: {
        type: Number,
        readOnly: true
      }
    },
    /**
     * Stores definition data.
     *
     * @private
     * @class
     * @property {!Graph} graph            - The definition's graph
     * @property {!array} unprocessedNodes - An array of nodes that haven't been processed
     * @property {!number} rootId          - The id to use for the root node of this definition's graph
     */
    _Definition: function() {
      this.graph = undefined;
      this.unprocessedNodes = [];
      this._rootId = undefined;
      // define the getter and setter for rootId
      // (ideally this should be done outside of this class definition)
      Object.defineProperty(this, 'rootId', {
        /**
         * Get the graph's root id.
         * If the graph hasn't been made yet, get the root id it will use.
         *
         * @returns {number} The root id
         */
        get: function() {
          // if there is a graph and it has a root
          if (this.graph && this.graph.root) {
            return this.graph.root.id;  // return the root's ids
          }
          return this._rootId;  // else return what the graph's root will be
        },
        /**
         * Set the graph's root id.
         * If the graph hasn't been made yet, set the id the graph will use for its root.
         *
         * @param {!number} val - The new id for the root
         * @returns {number} The new root id
         */
        set: function(val) {
          // if there is a graph and it has a root
          if (this.graph && this.graph.root) {
            // set and return the new id for the root
            this.graph.root.id = val;
            return this.graph.root.id;
          }
          // else set and return what the graph's root will be
          this._rootId = val;
          return this._rootId;
        }
      });
    },
    /**
     * @class
     * @param {!string} message - The error message
     */
    InterpreterException: function(message) {
      this.message = message;
      this.toString = function() {
        return 'InterpreterException: ' + this.message;
      };
    },
    /**
     * Parse the code and return the automata it defines.
     *
     * @param {!string} code - The code to parse
     * @returns {!Automaton[]} Automata
     */
    parse: function(code) {
      var pt = this._parser.parse(code);
      return this._interpretParseTree(pt);
    },
    /**
     * Reset the interpreter (reinitialise).
     *
     * @private
     */
    _resetInterpreter: function() {
      // call the private setters for these fields
      // (they're readOnly so they can't simply be set with '=')
      // jscs:disable requireCamelCaseOrUpperCaseIdentifiers
      // jshint -W106
      this._set_nextNodeId(0);
      this._set_nextEdgeId(0);
      this._set_definitionsMap({});
      // jscs:enable requireCamelCaseOrUpperCaseIdentifiers
    },
    /**
     * Interpret a parse tree generated by the parser and create an array of automata from it.
     *
     * @private
     * @param {!object[]} parseTree - A parse tree made by the parser (an array of parse tree model nodes)
     * @returns {!Automaton[]} Automata
     */
    _interpretParseTree: function(parseTree) {
      this._resetInterpreter();
      NodeUid.reset();
      EdgeUid.reset();
      // _interpretModel
      parseTree.forEach(function(model) {
        this._interpretDefinitions(model.definitions);
        var defName = model.definitions[0].name.name;
        this._interpretRelabelling(model.relabel, defName);
        this._interpretHiddenActions(model.hidden, defName);
      }.bind(this));
      this._processReferences();
      this._relabelNodes(true);
      return this._buildAutomataArray();
    },
    /**
     * Interpret the definitions defined in a parse tree.
     *
     * @private
     * @param {!object[]} definitions - An array of parse tree definitions
     */
    _interpretDefinitions: function(definitions) {
      var definitionMap;
      // for each definition in the model
      definitions.forEach(function(definition, index) {
        // first definition in the model? (eg A not B "A=x->B, B=y->STOP.")
        if (index === 0) {
          definitionMap = this._definitionsMap;  // use the global definition map
        }
        // get the name of this definition
        var name = this._getNameFromPTNode(definition.name);
        // if the definition does not exist, create it
        if (definitionMap[name] === undefined) {
          definitionMap[name] = new this._Definition();
        }
        // check if we have already processed a definition with this name
        if (definitionMap[name].graph !== undefined) {
          throw new this.InterpreterException('process "' + name + '" defined more that once.');
        }
        // create the graph for this definition
        definitionMap[name].graph = (definition.type === 'parallel-definition') ? this._interpretParallel(definition.process) : new Graph();
        // add the root node of the graph
        // if an id to use for the root has hasn't been specified, generate one, otherwise use it
        var rootId = definitionMap[name].rootId;

        var root = undefined;
        if(definition.type === 'definition'){
          root = definitionMap[name].graph.addNode(
            rootId === undefined ? NodeUid.nextNodeUid : rootId
          );
        }
        else{
          root = definitionMap[name].graph.root;
        }
        root.addMetaData ('startNode', true); // mark the root as the starting node (for the visualizer)
        var referenceMap = {};      // create the reference map
        referenceMap[name] = root;  // we already know that the root of this definition is root
        this._interpretProcess(definition.process, root, definitionMap, name, referenceMap);
      }.bind(this));
    },
    /**
     * Relabels edges defined as being relabelled in a parse tree.
     * 
     * @private
     * @param {!object[]} relabel - an object containing edges to be relabelled
     * @param {string} defName - name of the definition currently getting parsed in the parse tree
     */
    _interpretRelabelling: function(relabel, defName){
      // if relabel is undefined there are no edges to be relabelled
      if(relabel !== undefined){
        // get an array of edges in the current graph
        var edges = this._definitionsMap[defName].graph.edges;
        // check each edge to see if it needs to be updated
        edges.forEach(function(edge){
          for(var i = 0; i < relabel.length; i++){
            // only update the edge if it needs to be relabelled
            if(relabel[i]['old-label'] === edge.label){
              edge.label = relabel[i]['new-label'];
            }
          }
        }.bind(this));
      }
    },
    /**
     * Hides the edges defined as hidden in a parse tree.
     *
     * @private
     * @param {!object[]} hidden - an object containing edges to be hidden
     * @param {string} defName - name of the definition currently getting parsed in the parse tree
     */
    _interpretHiddenActions: function(hidden, defName){
      // if hidden is undefined there are no edges to change
      if(hidden !== undefined){
        // get an array of edges in the current graph
        var edges = this._definitionsMap[defName].graph.edges;
        // check each edge to see if it needs to be updated
        edges.forEach(function(edge, index){
          if(_.contains(hidden, edge.label)){
            // only updates the edge if it needs to be hidden
            edge.isHidden = true;
          }
        }.bind(this));
      }
    },
    /**
     * Interpret a parse tree process node.
     *
     * @private
     * @param {!object} process            - A parse tree process node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretProcess: function(process, extendtionNode, definitionMap, defName, referenceMap) {
      switch (process.type) {
        case 'sequence':
          this._interpretSequence(process, extendtionNode, definitionMap, defName, referenceMap);
          break;
        case 'choice':
          this._interpretChoice(process, extendtionNode, definitionMap, defName, referenceMap);
          break;
        //case 'parallel':
          //this._interpretParallel(process, extendtionNode, definitionMap, defName, referenceMap);
          //break;
        case 'parallel':
          break;
        case 'name':
          this._interpretName(process, extendtionNode, definitionMap, defName, referenceMap);
          break;
        case 'abstraction':
          this._interpretAbstraction(process, extendtionNode, definitionMap, defName, referenceMap);
          break;
        case 'simplification':
          this._interpretSimplification(process, extendtionNode, definitionMap, defName, referenceMap);
          break;
        case 'stop':
          this._interpretStop(process, extendtionNode, definitionMap, defName, referenceMap);
          break;
        case 'error':
          this._interpretError(process, extendtionNode, definitionMap, defName, referenceMap);
          break;
        default:
          console.error('Trying to interpret invalid process type "' + process.type + '"');
          break;
      }
    },
    /**
     * Interpret a parse tree sequence node.
     *
     * @private
     * @param {!object} sequence           - A parse tree sequence node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretSequence: function(sequence, extendtionNode, definitionMap, defName, referenceMap) {
      var graph = definitionMap[defName].graph;         // get the graph
      var node = graph.addNode(NodeUid.nextNodeUid);  // add a new node to the graph
      // check if edge being added is not a tau
      if(this._getActionFromNode(sequence.from) === 'tau'){
        throw new this.InterpreterException("\'tau\' is not a valid name for an action label.");
      }
      // add an edge connect the new node to the rest of the graph
      graph.addEdge(EdgeUid.nextEdgeUid, extendtionNode, node, this._getActionFromNode(sequence.from));
      this._interpretProcess(sequence.to, node, definitionMap, defName, referenceMap);
    },
    /**
     * Interpret a parse tree choice node.
     *
     * @private
     * @param {!object} choice             - A parse tree choice node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretChoice: function(choice, extendtionNode, definitionMap, defName, referenceMap) {
      this._interpretProcess(choice.option1, extendtionNode, definitionMap, defName, referenceMap);
      this._interpretProcess(choice.option2, extendtionNode, definitionMap, defName, referenceMap);
    },
    /**
     * Interpret a parse tree parallel node.
     *
     * @private
     * @param {!object} parallel           - A parse tree parallel node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    //_interpretParallel: function(parallel, extendtionNode, definitionMap, defName, referenceMap) {
    _interpretParallel: function(parallel) {
      var parallelDefName1 = parallel['definition1'].name;
      var parallelDefName2 = parallel['definition2'].name;

      // check if definitions have been labelled
      var label1 = parallel['definition1'].label;
      var label2 = parallel['definition2'].label;

      if(label1 !== undefined){
        this._interpretLabel(label1, parallelDefName1);
        parallelDefName1 = label1 + ":" + parallelDefName1;
      }

      if(label2 !== undefined){
        this._interpretLabel(label2, parallelDefName2);
        parallelDefName2 = label2 + ":" + parallelDefName2;
      }

      var graph = new Graph();
      var graph1 = this._definitionsMap[parallelDefName1].graph;
      var graph2 = this._definitionsMap[parallelDefName2].graph;
      var alphabet = graph1.alphabetUnion(graph2);
      
      // combine states
      for(var i = 0; i < graph1.nodeCount; i++){
        var terminalState1 = graph1.getNode(i + graph1.rootId)._meta['isTerminal'] === 'stop';
        
        for(var j = 0; j < graph2.nodeCount; j++){
          var terminalState2 = graph2.getNode(j + graph2.rootId)._meta['isTerminal'] === 'stop';
          var node = graph.addNode(NodeUid.nextNodeUid, (i + "." + j));

          // if both states are terminal make new node terminal
          if(terminalState1 && terminalState2){
            node.addMetaData('isTerminal', 'stop');
          }
        }
      }

      // add edges
      for(var i = 0; i < graph1.nodeCount; i++){
        var node1 = graph1.getNode(i + graph1.rootId);
          
        for(var j = 0; j < graph2.nodeCount; j++){
          var node2 = graph2.getNode(j + graph2.rootId);
          var fromId = (i * graph2.nodeCount) + j + graph.rootId;

          for(var action in alphabet){

            var coaccessible1 = node1.coaccessible(action); // either -1 or the node it transitions to
            var coaccessible2 = node2.coaccessible(action); // either -1 or the node it transitions to

            // check if an edge is needed from the current combined states
            if(coaccessible1 !== -1 && coaccessible2 !== -1) {
              var toId = ((coaccessible1 - graph1.rootId) * graph2.nodeCount) + (coaccessible2 - graph2.rootId) + graph.rootId;
              var isHidden = graph1.isHiddenEdge(action);
              graph.addEdge(EdgeUid.nextEdgeUid, graph.getNode(fromId), graph.getNode(toId), action, isHidden);
            }
            else if(coaccessible1 !== -1 && !graph2.containsEdgeInAlphabet(action)) {
              var toId = (coaccessible1 * graph2.nodeCount) + j + graph.rootId;
              var isHidden = graph1.isHiddenEdge(action);
              graph.addEdge(EdgeUid.nextEdgeUid, graph.getNode(fromId), graph.getNode(toId), action, isHidden);
            }
            else if(coaccessible2 !== -1 && !graph1.containsEdgeInAlphabet(action)) {
              var toId = (i * graph2.nodeCount) + (coaccessible2 - graph2.rootId) + graph.rootId;
              var isHidden = graph2.isHiddenEdge(action);
              graph.addEdge(EdgeUid.nextEdgeUid, graph.getNode(fromId), graph.getNode(toId), action, isHidden);
            }
          }
        }
      }

      graph.trim();
      return graph;
    },
    /**
     * Interpret a parse tree name node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree name node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretName: function(ptNode, extendtionNode, definitionMap, defName, referenceMap) {
      var references = this._getNameFromPTNode(ptNode);        // get what the extendtionNode should be referencing
      extendtionNode.addMetaData ('references', references);   // mark what the extendtionNode as referencing it
      // if there is no record of this reference yet
      if (referenceMap[references] === undefined) {
        referenceMap[references] = extendtionNode;                       // create a reference
        extendtionNode.addMetaData ('referenceUnprocessed', true);      // mark this reference as unprocessed
        definitionMap[defName].unprocessedNodes.push(extendtionNode);   // put it in the array of unprocessed references
        // if there is no definition for this reference
        if (definitionMap[references] === undefined) {
          definitionMap[references] = new this._Definition();    // create one
          definitionMap[references].rootId = extendtionNode.id;  // set what the root id should be for its graph
        }
        // if there is a definition for this reference
        else {
          extendtionNode.id = definitionMap[references].rootId;  // change the extendtionNode to use the right id
        }
      }
      // if there is a record of this reference
      else {
        definitionMap[defName].graph.mergeNodes([referenceMap[references].id, extendtionNode.id]);
      }
    },
    /**
     * Interprets a parse tree abstraction node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree abstraction node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretAbstraction: function(ptNode, extendtionNode, definitionMap, defName, referenceMap) {
      var isNested = false;
      var name = this._getNameFromPTNode(ptNode).name;
      // check if there are any nested functions within this process
      if(typeof(name) === 'object'){
        this._interpretProcess(ptNode.name, extendtionNode, definitionMap, defName, referenceMap);
        isNested = true;
      }
      var reference = this._getNameFromFunctionNode(ptNode);
      // throw an error if the definition to be abstracted has not been defined
      if(definitionMap[reference] === undefined){
        throw new this.InterpreterException('\'' + reference + '\' has not been defined.');
      }
      // perfrom the abstraction function on the required graph
      var graph = (isNested) ? definitionMap[defName].graph : definitionMap[reference].graph;
      definitionMap[defName].graph = graph.deepClone();
      definitionMap[defName].graph.abstraction();
    },
    /**
     * Interprets a parse tree simplification node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree simplification node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretSimplification: function(ptNode, extendtionNode, definitionMap, defName, referenceMap) {
      var isNested = false;
      var name = this._getNameFromPTNode(ptNode).name;
      // check if there are any nested functions within this process
      if(typeof(name) === 'object'){
        this._interpretProcess(ptNode.name, extendtionNode, definitionMap, defName, referenceMap);
        isNested = true;
      }
      var reference = this._getNameFromFunctionNode(ptNode);
      // throw an error if the definition to be simplified has not been defined
      if(definitionMap[reference] === undefined){
        throw new this.InterpreterException('\'' + reference + '\' has not been defined.');
      }
      // perform the bisimulation function on the required graph
      var graph = (isNested) ? definitionMap[defName].graph : definitionMap[reference].graph;
      definitionMap[defName].graph = graph.deepClone();
      definitionMap[defName].graph.bisimulation();
    },
    /**
     *
     */
    _interpretLabel: function(label, defName) {
      // clone the definition defined by defName
      var definition = this._definitionsMap[defName];
      var temp = new this._Definition();
      temp.graph = definition.graph.deepClone();
      temp.unprocessedNodes = definition.unprocessedNodes;
      temp._rootId = temp.graph.rootId;
      // relabel the edges in the new definition
      for(var i in temp.graph.edges){
        var edge = temp.graph.getEdge(i);
        var newLabel = label + ":" + edge.label;
        edge.label = newLabel;
      }
      // add new definition to definitions map
      this._definitionsMap[label + ":" + defName] = temp;
      definition.isHidden = true;
    },
    /**
     * Interpret a parse tree stop node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree stop node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretStop: function(ptNode, extendtionNode, definitionMap, defName, referenceMap) {
      extendtionNode.addMetaData ('isTerminal', 'stop');
    },
    /**
     * Interpret a parse tree error node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree error node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretError: function(ptNode, extendtionNode, definitionMap, defName, referenceMap) {
      extendtionNode.addMetaData ('isTerminal', 'error');
    },
    /**
     * Get the name from a parse tree name node.
     *
     * @private
     * @param {!object} ptNode - A parse tree name node
     * @returns {string}
     */
    _getNameFromPTNode: function(ptNode) {
      return ptNode.name;
    },
    /**
     *
     */
    _getNameFromFunctionNode: function(functionNode) {
      var name = functionNode.name;
      while(typeof(name) !== 'string'){
        name = name.name;
      }
      return name;
    },
    /**
     * Get the action from a parse tree action node.
     *
     * @private
     * @param {!object} ptNode - A parse tree action node
     * @returns {string}
     */
    _getActionFromNode: function(ptNode) {
      return ptNode.action;
    },
    /**
     * Process all the unprocessed references.
     *
     * @private
     */
    _processReferences: function() {
      // for each definitions
      for (var key in this._definitionsMap) {
        var prevReferences = key;   // for correct error messages
        // while it has un processed nodes
        while (this._definitionsMap[key].unprocessedNodes.length > 0) {
          var definition = this._definitionsMap[key];
          var len = this._definitionsMap[key].unprocessedNodes.length;
          var references;
          // loop through all the unprocessed nodes
          // (only the ones that were marked as un processed when the while loop started,
          // not any new unprocessed nodes that were added)
          for (var i = 0; i < len; i++) {
            var node = definition.unprocessedNodes[i];
            references = node.getMetaData ('references');
            // check whether or not the automaton that this node is referencing actual exist.
            if (this._definitionsMap[references] === undefined ||
                this._definitionsMap[references].graph === undefined) {
              throw new this.InterpreterException('unknown automaton "' + references + '" referenced in "' + prevReferences + '".');
            }
            var refGraph = this._definitionsMap[references].graph;
            var refNodes = refGraph.nodes;
            // add the nodes and edge from the referenced graph in to this one
            definition.graph.combineWith(refGraph);
            // find all the unprocessed nodes that we are adding to this graph
            // and add them to the array of unprocessed nodes
            for (var j = 0; j < refNodes.length; j++) {
              var gRefNode = definition.graph.getNode(refNodes[j].id);
              if (gRefNode.getMetaData ('referenceUnprocessed')) {
                definition.unprocessedNodes.push(gRefNode);
              }
            }
            node.deleteMetaData ('referenceUnprocessed'); // this node has now been processed
          }
          // remove all the nodes we just processed from the unprocessed nodes array
          definition.unprocessedNodes.splice(0, len);
          prevReferences = references;
        }
      }
    },
    /**
     * Returns an array of actions that are to be relabelled and what they are to be relabelled to
     *
     * @private
     * @param {!object[] || Array} relabel - either an object or an array of objects
     */
    _processRelabelledActions: function(relabel){
      var relabels = relabel.relabels.relabels;
      if(relabels instanceof Array){
        var temp = [];
        // add the objects containing new and old labels to temp
        for(var i = 0; i < relabels.length; i++){
          temp[i] = relabels[i].relabels;
        }
        return temp;
      }
      return [relabels];
    },
    /**
     * Returns an array of actions that are defined as hidden.
     *
     * @private
     * @param {string || [string]} hidden - either a string or an array of strings
     */
    _processHiddenActions: function(hidden) {
      var hide = hidden.hidden.hidden;
      if(typeof hide === 'string'){
        return [hide];
      }
      return hide;
    },
    /**
     * Relabel the nodes in each automata definition.
     * Done by performing a depth first search of the graph.
     *
     * @private
     * @param {boolean} showRefs - If set will prefix reference nodes' labels with the automaton they reference
     * @param {boolean} useIds   - If set will use the nodes' id as the label
     */
    _relabelNodes: function(showRefs, useIds) {
      for (var key in this._definitionsMap) {
        var label = 0;
        var visitedNodes = {};
        var fringe = [];
        fringe.push(this._definitionsMap[key].graph.root);
        while (fringe.length > 0) {
          var node = fringe.shift();
          // if already visited
          if (visitedNodes[node.id]) {
            continue; // don't do anything with this node and start on the next one
          }
          visitedNodes[node.id] = node;   // mark as visited
          // label the node
          var ref = node.getMetaData ('references');
          if (showRefs && ref && ref !== this.name) {
            node.label = ref + ':';
          } else {
            node.label = '';
          }
          node.label += useIds ? 'n' + node.id : label++;
          // loop through all the current node's neighbors
          var neighbors = node.neighbors;
          for (var i in neighbors) {
            // if neighbor is unvisited
            if (!visitedNodes[neighbors[i].id]) {
              fringe.push(neighbors[i]);
            }
          }
        }
      }
    },
    /**
     * Takes all the automaton definitions and construct an array of automata.
     *
     * @private
     * @returns {!Automaton[]} Automata
     */
    _buildAutomataArray: function() {
      var automata = [];
      for (var key in this._definitionsMap) {
        automata.push(new Automaton(key, this._definitionsMap[key].graph));
      }
      return automata;
    },
    /**
     * Create the next unique node ID and return the previous one.
     *
     * @private
     * @returns {!number} a unique node ID
     */
    _useNextNodeUid: function() {
      var v = this._nextNodeId;
      // jscs:disable requireCamelCaseOrUpperCaseIdentifiers
      // jshint -W106
      this._set_nextNodeId(v + 1);
      // jscs:enable requireCamelCaseOrUpperCaseIdentifiers
      return v;
    },
    /**
     * Create the next unique edge ID and return the previous one.
     *
     * @private
     * @returns {!number} a unique edge ID
     */
    _useNextEdgeUid: function() {
      var v = this._nextEdgeId;
      // jscs:disable requireCamelCaseOrUpperCaseIdentifiers
      // jshint -W106
      this._set_nextEdgeId(v + 1);
      // jscs:enable requireCamelCaseOrUpperCaseIdentifiers
      return v;
    }
  });
})();
</script>