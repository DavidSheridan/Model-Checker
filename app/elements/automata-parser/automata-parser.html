<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">
<link rel="import" href="../imports/graph.html">
<link rel="import" href="../imports/automaton.html">

<script>
// jshint -W098
(function() {
  Polymer({
    is: 'automata-parser',
    properties: {
      /**
       * The PEGjs parser.
       * Used to create a parse tree that we can the interpret.
       *
       * @private
       */
      _parser: {
        type: Object,
        value: PEG.automataParser, // created in parser.js
        readOnly: true
      },
      /**
       * A Map of automaton names to their definition.
       *
       * @private
       */
      _definitionsMap: {
        type: Object,
        readOnly: true
      },
      /**
       * Determines whether automata are built or not.
       *
       * @private
       */
      _buildAutomata: {
        type: Boolean,
        readOnly: true
      },
      /**
       * Determines whether fair or unfair abstraction is performed.
       *
       * @private
       */
      _isFairAbstraction: {
        type: Boolean,
        readOnly: true
      },
      /**
       * A Map of operations to boolean which determines whether the
       * operation passed or failed.
       *
       * @private
       */
      _operationsMap: {
        type: Object,
        readOnly: true
      },
      /**
       * Current index for operations map.
       */
      _operationsIndex: {
        type: Number,
        readOnly: true
      },
      /**
       * Unique identifier for operations definitions.
       *
       * @private
       */
      _operationUid: {
        type: Number,
        readOnly: true
      },
      /**
       * A stack of the current composite interpretations in progress.
       *
       * @private
       */
      _compositeStack: {
        type: Array,
        readOnly: true
      },
      /**
       * A map of constant variable names to their values.
       *
       * @private
       */
      _constantsMap: {
        type: Object,
        readOnly: true
      }
    },
    /**
     * Stores definition data.
     *
     * @private
     * @class
     * @property {!Graph} graph            - The definition's graph
     * @property {!string} type            - The type of this definition
     * @property {!array} relabel          - An array of javascript objects containing relabelling data
     * @property {!array} hidden           - An array containing actions to be hidden
     * @property {!boolean} isVisible      - Determines whether or not the graph is visualised
     * @property {!array} unprocessedNodes - An array of nodes that haven't been processed
     * @property {!number} rootId          - The id to use for the root node of this definition's graph
     */
    _Definition: function() {
      this.graph = undefined;
      this.label = undefined;
      this.relabel = undefined;
      this.hidden = undefined;
      this.isVisible = undefined;
      this.unprocessedNodes = [];
      this._rootId = undefined;
      // define the getter and setter for rootId
      // (ideally this should be done outside of this class definition)
      Object.defineProperty(this, 'rootId', {
        /**
         * Get the graph's root id.
         * If the graph hasn't been made yet, get the root id it will use.
         *
         * @returns {number} The root id
         */
        get: function() {
          // if there is a graph and it has a root
          if (this.graph && this.graph.root) {
            return this.graph.root.id;  // return the root's ids
          }
          return this._rootId;  // else return what the graph's root will be
        },
        /**
         * Set the graph's root id.
         * If the graph hasn't been made yet, set the id the graph will use for its root.
         *
         * @param {!number} val - The new id for the root
         * @returns {number} The new root id
         */
        set: function(val) {
          // if there is a graph and it has a root
          if (this.graph && this.graph.root) {
            // set and return the new id for the root
            this.graph.root.id = val;
            return this.graph.root.id;
          }
          // else set and return what the graph's root will be
          this._rootId = val;
          return this._rootId;
        }
      });
    },
    /**
     * @class
     * @param {!string} message - The error message
     */
    InterpreterException: function(message) {
      this.message = message;
      this.toString = function() {
        return 'InterpreterException: ' + this.message;
      };
    },
    /**
     * Parse the code and return the automata it defines.
     *
     * @param {!string} code - The code to parse
     * @param {!boolean} isFair - Determines whether fair or unfair abstraction is performed
     * @returns {!Automaton[]} Automata
     */
    parse: function(code, build, isFair) {
      this._set_buildAutomata(build);
      this._set_isFairAbstraction(isFair);
      var pt = this._parser.parse(code);
      return this._interpretParseTree(pt);
    },
    /**
     * Reset the interpreter (reinitialise).
     *
     * @private
     */
    _resetInterpreter: function() {
      // call the private setters for these fields
      // (they're readOnly so they can't simply be set with '=')
      this._set_definitionsMap({});
      this._set_operationsMap({});
      this._set_operationsIndex(0);
      this._set_operationUid(0);
      this._set_compositeStack([]);
      this._set_constantsMap({});
      this._set_rangesMap({});
      this._set_setsMap({});
      // reset the node and edge uids in graph class
      NodeUid.reset();
      EdgeUid.reset();
    },
    /**
     * Interpret a parse tree generated by the parser and create an array of automata from it.
     *
     * @private
     * @param {!object[]} parseTree - A parse tree made by the parser (an array of parse tree model nodes)
     * @returns {!Automaton[]} Automata
     */
    _interpretParseTree: function(parseTree) {
      this._resetInterpreter();
      parseTree.forEach(function(model) {
        // ignore comments
        switch(model.type){
          case 'model':
            this._interpretDefinitions(model);
            break;
          case 'operation':
            this._interpretOperation(model);
            break;
          case 'constant':
            this._interpretConstant(model);
            break;
          case 'range':
            this._interpretRange(model);
            break;
          case 'set':
            this._interpretSet(model);
            break;
          case 'comment':
            break; // ignore comments
          default:
            console.error('Trying to interpret invalid model type "' + model.type + '"');
            break;
        }
      }.bind(this));

      // only relabel nodes if live building is active
      if(this._buildAutomata){
        this._relabelNodes(true);
      }

      return this._buildParsingResults();
    },
    /**
     * Interpret the definitions defined in the specified model.
     *
     * @private
     * @param {!object[]} model - contains an array of definitions as well as any relabelling and hiding defined
     */
    _interpretDefinitions: function(model) {
      var definitionMap = this._definitionsMap;
      var globalName = this._getNameFromPTNode(model.definitions[0].name);
      this._initialiseDefinitions(model.definitions, globalName);
      
      // only interpret definitions if live build is active
      if(this._buildAutomata){
        model.definitions.forEach(function(definition, index) {
          // get the name of this definition
          var name = this._getNameFromPTNode(definition.name);
          if (index !== 0) {
            name = globalName + '.' + name;
          }

          // check if we have already processed a definition with this name
          if (definitionMap[name].graph !== undefined) {
            throw new this.InterpreterException('process "' + name + '" defined more that once.');
          }
        
          // create the graph for this definition
          definitionMap[name].graph = new Graph();
          // set the type for this definition
          definitionMap[name].type = definition.type;
          definitionMap[name].relabel = definition.relabel;
          definitionMap[name].hidden = definition.hidden;
          definitionMap[name].isVisible = definition.isVisible;

          // add the root node of the graph
          // if an id to use for the root has hasn't been specified, generate one, otherwise use it
          var rootId = definitionMap[name].rootId;
          var root = definitionMap[name].graph.addNode(
            rootId === undefined ? NodeUid.next : rootId
          );
          root.addMetaData ('startNode', true); // mark the root as the starting node (for the visualizer)
          
          // if this is a local definition set it to be invisible
          if(index > 0){
            definitionMap[name].isVisible = false;
          }

          var referenceMap = {};
          var variableMap = {};
          referenceMap[name] = root;  // we already know that the root of this definition is root
          this._interpretProcess(definition.process, root, definitionMap, name, globalName, referenceMap, variableMap);
        }.bind(this));
        
        // process the global definition
        this._processDefinition(globalName, model);
      }
    },
    /**
     * Interprets the operation defined in the specified model.
     *
     * @private
     * @param {!object} model - contains the operation along with the definitions to perform the operation on
     */
    _interpretOperation: function(model) {
      // construct definitions for this operation
      var defNames = [];
      var process = model.process;
      var definitionMap = this._definitionsMap;
      var definitions = [model.definition1, model.definition2];
      
      for(var i = 0; i < 2; i++){
        var name = this._nextOperationUid();
        this._constructDefinition(name, definitions[i].type, false);
        defNames.push(name);

        this._interpretProcess(definitions[i], definitionMap[defNames[i]].graph.root, definitionMap, defNames[i], defNames[i], {}, {});
        this._processDefinition(defNames[i]);
      }

      this._processOperation(process, this._definitionsMap, defNames[0], defNames[1], model.input, model.isNegated, model.position);
    },
    /**
     * Interprets the constant defined in the specified model.
     *
     * @private
     * @param {!object} model - contains the constants name and the value to be assigned to it
     */
    _interpretConstant: function(model) {
      // check if the name is valid
      if(!this._isValidName(model.name)){
        throw new this.InterpreterException('The name "' + model.name + '" has been defined already.');
      }
      // add constant to constants map
      this._constantsMap[model.name] = model.value;
    },
    /**
     * Interprets the range defined in the specified model.
     *
     * @private
     * @param {!object} model - contains the ranges name and the range to be assigned to it
     */
    _interpretRange: function(model) {
      // check if the name is valid
      if(!this._isValidName(model.name)){
        throw new this.InterpreterException('The name "' + model.name + '" has been defined already.');
      }

      // process the range
      var range = this._processRange(model.range, model.name);

      // add constant to constants map
      this._constantsMap[model.name] = range;
    },
    /**
     *
     */
    _interpretSet: function(model) {
      // check if the name is valid
      if(!this._isValidName(model.name)){
        throw new this.InterpreterException('The name "' + model.name + '" has been defined already.');
      }

      // process the set
      var set = this._processSet(model.set);

      // add set to sets map
      this._constantsMap[model.name] = set;
    },
    /**
     * Interpret a parse tree process node.
     *
     * @private
     * @param {!object} process            - A parse tree process node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretProcess: function(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      switch (process.type) {
        case 'definition':
          this._interpretDefinition(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'sequence':
          this._interpretSequence(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'choice':
          this._interpretChoice(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'parallel':
          this._interpretParallel(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'composite':
          this._interpretComposite(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'name':
          this._interpretName(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'label':
          this._interpretLabel(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'abstraction':
          this._interpretAbstraction(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'simplification':
          this._interpretSimplification(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'stop':
          this._interpretStop(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'error':
          this._interpretError(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        default:
          console.error('Trying to interpret invalid process type "' + process.type + '"');
          break;
      }
    },
    /**
     *
     */
    _interpretDefinition: function(definition, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      this._interpretProcess(definition.process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
    },
    /**
     * Interpret a parse tree sequence node.
     *
     * @private
     * @param {!object} sequence           - A parse tree sequence node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretSequence: function(sequence, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var graph = definitionMap[defName].graph;         // get the graph
      var node = graph.addNode(NodeUid.next);
      var action = this._processActionNode(sequence.from, variableMap);

      if(typeof(action) === 'object'){
        var prefix = undefined;
        var variable = undefined;

        // define variable if this is an indexed action
        if(action.type === 'index'){
          variable = action.variable.name;
          prefix = action.action;
          action = action.index;
        }
        
        if(action.type === 'set'){
          for(var i = 0; i < action.set.length; i++){
            // update variable reference if variable is defined
            if(variable !== undefined){
              variableMap[variable] = action.set[i];
            }

            var label = (prefix === undefined) ? action.set[i] : (prefix + '.' + action.set[i]);
            graph.addEdge(EdgeUid.next, extendtionNode, node, label);
          }
        }
        else if(action.type === 'range'){
          for(var i = action.start; i < action.end; i++){
            // update variable reference if variable is defined
            if(variable !== undefined){
              variableMap[variable] = i;
            }

            var label = (prefix === undefined) ? '[' + i + ']' : prefix + '[' + i + ']';
            graph.addEdge(EdgeUid.next, extendtionNode, node, label);
          }          
        }
      }
      else{
        graph.addEdge(EdgeUid.next, extendtionNode, node, action);
      }

      this._interpretProcess(sequence.to, node, definitionMap, defName, globalName, referenceMap, variableMap);
    },
    /**
     * Interpret a parse tree choice node.
     *
     * @private
     * @param {!object} choice             - A parse tree choice node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretChoice: function(choice, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      this._interpretProcess(choice.option1, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
      this._interpretProcess(choice.option2, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
    },
    /**
     * Interpret a parse tree parallel node.
     *
     * @private
     * @param {!object} parallel           - A parse tree parallel node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretParallel: function(parallel, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var defs = [parallel.definition1, parallel.definition2];
      
      for(var i = 0; i < defs.length; i++){
        var name = defName + '.' + i;
        // push name to composite stack
        this._pushToCompositeStack(name);
        this._constructDefinition(name, defs[i].type, defs[i].relabel, defs[i].hidden, false);
        var process = (defs[i].process === undefined) ? defs[i] : defs[i].process;
        this._interpretProcess(process, definitionMap[name].graph.root, definitionMap, name, name, referenceMap);
        this._processDefinition(name);
      }

      var graph1 = definitionMap[defName + '.0'].graph;
      var graph2 = definitionMap[defName + '.1'].graph;
      var graph = Graph.Operations.parallelComposition(graph1, graph2);
      definitionMap[defName].graph = graph;
      definitionMap[defName].graph.root = graph.root;

      this._pushToCompositeStack(defName);
    },
    /**
     *
     */
    _interpretComposite: function(composite, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      this._interpretProcess(composite.composite, extendtionNode, definitionMap, defName, globalName, {}, variableMap);
      var name = this._popFromCompositeStack();
      // update the label for the defintion if necessary
      if(composite.label !== undefined){
        var label = composite.label.action;
        definitionMap[name].label = label;
      }
    },
    /**
     * Interpret a parse tree name node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree name node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretName: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var references = this._getNameFromPTNode(ptNode);        // get what the extendtionNode should be referencing

      // check if this is a local reference
      var localReference = globalName + '.' + references;
      if(definitionMap[localReference] !== undefined){
        references = localReference;
      }

      this._interpretReference(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap, references);
    },
    /**
     * Interprets a parse tree labelled name node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree name node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretLabel: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var name = this._getNameFromPTNode(ptNode);
      var label = this._getLabelFromPTNode(ptNode);

      if(label === undefined){
        return;
      }

      // clone the definition defined by defName
      var definition = this._definitionsMap[name];
      
      // throw error if definition is undefined
      if(definition === undefined){
        throw new this.InterpreterException('Unknown automaton \'' + name + '\' attempted to be referenced.');
      }

      var temp = new this._Definition();
      temp.graph = definition.graph.deepClone();
      temp.unprocessedNodes = definition.unprocessedNodes;
      temp._rootId = temp.graph.rootId;
      temp.isVisible = false;

      // relabel the edges in the new definition
      for(var i in temp.graph.edges){
        var edge = temp.graph.getEdge(i);
        var newLabel = label + "." + edge.label;
        edge.label = newLabel;
      }

      var references = label + ':' + name;
      // add new definition to definitions map
      this._definitionsMap[references] = temp;

      this._interpretReference(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap, references);       
    },
    /**
     * Interprets a reference for either a name or labelled name node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree name node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     * @param {!string} references         - The reference to interpret
     */
    _interpretReference: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap, references) {
      // if there is no record of this reference yet
      if (referenceMap[references] === undefined) {
        var metaData = extendtionNode.getMetaData('references');
        if(metaData === undefined){
          extendtionNode.addMetaData ('references', [references]);
        }
        else{
          extendtionNode.addMetaData('references', metaData.concat(references));
        }
        referenceMap[references] = extendtionNode;                       // create a reference
        extendtionNode.addMetaData ('referenceUnprocessed', true);      // mark this reference as unprocessed
        definitionMap[defName].unprocessedNodes.push(extendtionNode);   // put it in the array of unprocessed references
        // if there is no definition for this reference
        if (definitionMap[references] === undefined || definitionMap[references].graph === undefined) {
          definitionMap[references] = new this._Definition();    // create one
          definitionMap[references].rootId = extendtionNode.id;  // set what the root id should be for its graph
        }
        // if there is a definition for this reference
        else {
          extendtionNode.id = definitionMap[references].rootId;  // change the extendtionNode to use the right id
        }
      }
      // if there is a record of this reference
      else {
        definitionMap[defName].graph.mergeNodes([referenceMap[references].id, extendtionNode.id]);
      }
    },
    /**
     * Interprets a parse tree abstraction node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree abstraction node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretAbstraction: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var references = this._interpretFunction(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);

      // throw an error if the definition to be abstracted has not been defined
      if(definitionMap[references] === undefined){
        throw new this.InterpreterException('\'' + reference + '\' has not been defined.');
      }

      var graph = definitionMap[references].graph;
      definitionMap[defName].graph = Graph.Operations.abstraction(graph, this._isFairAbstraction);
      extendtionNode.id = definitionMap[defName].graph.root.id;
    },
    /**
     * Interprets a parse tree simplification node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree simplification node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretSimplification: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var references = this._interpretFunction(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);

      // throw an error if the definition to be simplified has not been defined
      if(definitionMap[references] === undefined){
        throw new this.InterpreterException('\'' + reference + '\' has not been defined.');
      }

      var graph = definitionMap[references].graph;
      definitionMap[defName].graph = Graph.Operations.simplification(graph);
      extendtionNode.id = definitionMap[defName].graph.root.id;
    },
    /**
     * Helper function for function definitions which interprets the contents within the function
     * before the function is applied to the contents.
     *
     * @private
     * @param {!object} ptNode             - A parse tree simplification node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     * @returns {!string}                  - A reference to the definition containing the contents of the function 
     */
    _interpretFunction: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var name;
      var references;
      var process = ptNode.process;
      
      if(process.type === 'definition'){
        name = defName + '.0';
        references = name;
        this._constructDefinition(name, process.type, process.relabel, process.hidden, false);
        this._interpretProcess(process.process, definitionMap[name].graph.root, definitionMap, name, globalName, referenceMap, variableMap);
        this._processDefinition(name);
      }
      else{
        var name = this._getNameFromPTNode(process).name;
        var references = this._getNameFromOperationNode(process);
      }

      // check if there are any nested functions within this process
      if(typeof(references) === 'object'){
        this._interpretProcess(ptNode.name, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
        references = defName;
      }
      return references;
    },
    /**
     * Interpret a parse tree stop node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree stop node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretStop: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      extendtionNode.addMetaData ('isTerminal', 'stop');
    },
    /**
     * Interpret a parse tree error node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree error node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretError: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      // add a deadlock edge from extendtion node
      var graph = definitionMap[defName].graph;
      var node = graph.addNode(NodeUid.next);
      graph.addEdge(EdgeUid.next, extendtionNode, node, '', false, true);
      node.addMetaData ('isTerminal', 'error');
    },

    /**
     *
     */
    _processActionNode: function(ptNode, variableMap) {

      switch(ptNode.type){
        case 'simple-expression':
          return ptNode.expression;
        case 'set':
          return this._processSet(ptNode.set);
        case 'range':
          return this._processRange(ptNode);
      }

      switch(ptNode.subtype){
        case undefined:
          return this._getActionFromNode(ptNode);
        case 'expression':
          return this._processExpressionActionNode(ptNode, variableMap);
        case 'joined':
          return this._processJoinedActionNode(ptNode, variableMap);
        case 'index':
          return this._processIndexActionNode(ptNode, variableMap);
      }
    },

    _processExpressionActionNode: function(ptNode, variableMap) {
        var action = this._getActionFromNode(ptNode);
        var expressions = ptNode.expressions;
        
        for(var i = 0; i < expressions.length; i++){
          var temp = this._processActionNode(expressions[i]);
          action += '[' + temp + ']';
        }

        return action;
    },

    _processJoinedActionNode: function(ptNode, variableMap) {
        var actions = ptNode.actions;
        var action = '';
        
        for(var i = 0; i < actions.length; i++){
          var temp = this._processActionNode(actions[i]);
          var result = (i == 0) ? '' : '.';
          action += (result + temp);
        }

        return action; 
    },

    _processIndexActionNode: function(ptNode, variableMap) {
      var index = this._processActionNode(ptNode.index);
      return {type: 'index', variable: ptNode.variable, action: ptNode.action, index: index}
    },

    /**
     *
     */
    _processExpression: function(ptNode, variableMap) {
      var result;
      var operand1 = this._processOperand(ptNode.operand1, variableMap);
      var operand2 = this._processOperand(ptNode.operand2, variableMap);

      switch(ptNode.operator){
        case '||': // or
          result = (Boolean(operand1) || Boolean(operand2));
          break;
        case '&&': // and
          result = (Boolean(operand1) && Boolean(operand2));
          break;
        case '|': // bitwise or
          result = Boolean(operand1 | operand2);
          break;
        case '^': // bitwise exclusive or
          result = Boolean(operand1 ^ operand2);
          break;
        case '&':// bitwise and
          result = Boolean(operand1 & operand2);
          break;
        case '==': // equal
          result = Boolean(operand1 == operand2);
          break;
        case '!=': // not equal
          result = Boolean(operand1 != operand2);
          break;
        case '<': // les than
          result = Boolean(operand1 < operand2);
          break;
        case '<=': // lest than or equal
          result = Boolean(operand1 <= operand2);
          break;
        case '>': // greater than
          result = Boolean(operand1 > operand2);
          break;
        case '>=': // greater than or equal
          result = Boolean(operand1 >= operand2);
          break;
        case '<<': // shift left
          result = operand1 << operand2;
          break;
        case '>>': // shift right
          result = operand1 >> operand2;
          break;
      }

      return result;
    },

    /**
     *
     */
    _processOperand: function(operand, variableMap) {
      // check if operand is a number
      var type = typeof(operand);
      if(type === 'number'){
        return operand;
      }

      // check if operand is a variable name
      if(type === 'string'){
        // check if variable is locally defined or a constant
        if(variableMap[operand] !== undefined){
          return variableMap[operand];
        }
        else if(this._constantsMap[operand] !== undefined){
          return this._constantsMap[operand];
        }

        // throw expression if variable cannot be located
        throw new this.InterpreterException('\'' + operand + '\' has not been defined.');
      }

      // process expression
      return this._processExpression(operand, variableMap);
    },
    /**
     *
     */
    _processOperation: function(process, definitionMap, defName1, defName2, input, isNegated, position) {
      var result = false;
      switch(process){
        case 'bisimulation':
          result = this._processBisimulation(definitionMap, defName1, defName2, input);
          break;
        default:
          console.error('Trying to interpret invalid process type "' + process + '"');
          break;
      }

      // negate the result if the not operator was used
      if(isNegated){
        result = !result;
      }
      var i = this._nextOperationsIndex();
      this._operationsMap[i] = {input: input, result: result, position: position};
    },
    /**
     *
     */
    _processBisimulation: function(definitionMap, defName1, defName2, input) {
      var graph1 = definitionMap[defName1].graph;
      var graph2 = definitionMap[defName2].graph;
      return Graph.Operations.isEquivalent(graph1, graph2);
    },
    /**
     * Get the name from a parse tree name node.
     *
     * @private
     * @param {!object} ptNode - A parse tree name node
     * @returns {string}
     */
    _getNameFromPTNode: function(ptNode) {
      var name = ptNode.name || ptNode.composite;
      if(name === undefined){
        throw this.InterpreterException('Failed to parse a name from ' + ptNode);
      }

      while(name.name !== undefined || name.composite !== undefined){
        name = name.name || ptNode.composite;
      }
      return name;
    },
    /**
     * Get the label from a parse tree labelled name node
     *
     * @private
     * @param {!object} ptNode - A parse tree labelled name node
     * @returns {string}  
     */
    _getLabelFromPTNode: function(ptNode) {
      return ptNode.label.action;
    },
    /**
     * Recurses through an operation node to get the name of the definition
     * that the operation is referencing.
     *
     * @private
     * @param {!object} operationNode - A parse tree operation node
     */
    _getNameFromOperationNode: function(operationNode) {
      var name = operationNode.name;
      while(typeof(name) !== 'string'){
        name = name.name;
      }
      return name;
    },
    /**
     * Get the action from a parse tree action node.
     *
     * @private
     * @param {!object} ptNode - A parse tree action node
     * @returns {string}
     */
    _getActionFromNode: function(ptNode) {
      return ptNode.action;
    },
    /**
     * Constructs and returns an empty definition.
     *
     * @private
     */
    _constructDefinition: function(defName, type, relabel, hidden, isVisible) {
      // check that there is not already a definition with the specified name
      if(this._definitionsMap[defName] !== undefined){
        throw new this.InterpreterException('process \'' + defName + '\' defined more that once.');
      }

      this._definitionsMap[defName] = new this._Definition();
      this._definitionsMap[defName].graph = new Graph();
      var rootId = this._definitionsMap[defName].rootId;
      var root = this._definitionsMap[defName].graph.addNode(
        rootId === undefined ? NodeUid.next : rootId
      );
      root.addMetaData('startNode', true);
      this._definitionsMap[defName].type = type;
      this._definitionsMap[defName].relabel = relabel;
      this._definitionsMap[defName].hidden = hidden;
      this._definitionsMap[defName].isVisible = isVisible;
    },
    /**
     * Initialises all of the definitions defined within the specified definition to the 
     * definitions map. This is to help in determining whether a reference is either
     * global or local.
     *
     * @private
     * @param {!array} definitions - array of definitions
     * @param {!string} globalName - the global name for the specified definitions
     */
    _initialiseDefinitions: function(definitions, globalName) {
      // check that there is not already a definition with the specified name
      if(this._definitionsMap[globalName] !== undefined){
        throw new this.InterpreterException('process \'' + globalName + '\' defined more that once.');
      }

      // process local definitions
      for(var i = 1; i < definitions.length; i++){
        var name = this._getNameFromPTNode(definitions[i].name);
        name = globalName + '.' + name;
        this._definitionsMap[name] = new this._Definition();
      }

      this._definitionsMap[globalName] = new this._Definition();
    },
    /**
     * Runs the processing of references, parallel composition, relabelling and hiding for
     * the specified definition. 
     *
     * @private
     * @param {!string} defName - the definition to process
     */
    _processDefinition: function(defName) {
      this._processReferences(defName);
      this._processLabelling(defName);
      this._processRelabelling(defName);
      this._processHiding(defName);
    },
    /**
     * Process all the unprocessed references for the specified definition.
     *
     * @private
     */
    _processReferences: function(defName) {
      var prevReferences = defName;   // for correct error messages
      // while it has un processed nodes
      while (this._definitionsMap[defName].unprocessedNodes.length > 0) {
        var definition = this._definitionsMap[defName];
        var len = this._definitionsMap[defName].unprocessedNodes.length;
        var references;
        // loop through all the unprocessed nodes
        // (only the ones that were marked as un processed when the while loop started,
        // not any new unprocessed nodes that were added)
        for (var i = 0; i < len; i++) {
          var node = definition.unprocessedNodes[i];
          refs = node.getMetaData ('references');
          for(var j = 0; j < refs.length; j++){
            references = refs[j];
            var localReference = defName + '.' + references;
            // check whether or not the automaton that this node is referencing actual exist.
            if(this._definitionsMap[localReference] === undefined || this._definitionsMap[localReference].graph === undefined){
              if(this._definitionsMap[references] === undefined || this._definitionsMap[references].graph === undefined) {
                throw new this.InterpreterException('unknown automaton "' + references + '" referenced in "' + prevReferences + '".');
              }
            }
            else{
              references = localReference;
            }
            
            var refGraph = this._definitionsMap[references].graph;
            var refNodes = refGraph.nodes;
            // set the current nodes id to the root of the reference graph
            node.id = refGraph.root.id;
            // add the nodes and edge from the referenced graph in to this one
            definition.graph.combineWith(refGraph);
            // find all the unprocessed nodes that we are adding to this graph
            // and add them to the array of unprocessed nodes
            for (var k = 0; k < refNodes.length; k++) {
              var gRefNode = definition.graph.getNode(refNodes[k].id);
              if (gRefNode.getMetaData ('referenceUnprocessed')) {
                definition.unprocessedNodes.push(gRefNode);
              }
            }
            node.deleteMetaData ('referenceUnprocessed'); // this node has now been processed
          }
        }
        // remove all the nodes we just processed from the unprocessed nodes array
        definition.unprocessedNodes.splice(0, len);
        prevReferences = references;
      }
    },
    /**
     *
     */
    _processLabelling: function(defName) {
      var label = this._definitionsMap[defName].label;
      if(label !== undefined){
        var edges = this._definitionsMap[defName].graph.edges;
        // relabel all the edges in the definition
        edges.forEach(function(edge){
          var newLabel = label + "." + edge.label;
          edge.label = newLabel;
        }.bind(this));
      }
    },
    /**
     * Process the relabelling of transitions for the specified definition.
     *
     * @private
     * @param {!string} defName - the definition to perform relabelling for
     */
    _processRelabelling: function(defName) {
      var relabel = this._definitionsMap[defName].relabel;
      if(relabel !== undefined){
        relabel = this._processRelabellingSet(relabel);
        // get an array of edges in the current graph
        var edges = this._definitionsMap[defName].graph.edges;
        // check each edge to see if it needs to be updated
        edges.forEach(function(edge){
          for(var i = 0; i < relabel.length; i++){
            // only update the edge if it needs to be relabelled
            var oldLabel = relabel[i]['old'];
            var newLabel = relabel[i]['new'];
            if(oldLabel === edge.label){
              edge.label = newLabel;
            }
          }
        }.bind(this));
      }
    },

    /**
     * Processes and returns the set of relabelling objects.
     *
     * @private
     * @param {!object} set - the set of relabelling objects to process
     * @returns {!object} processed set
     */
    _processRelabellingSet: function(set) {
      var result = [];
      for(var i = 0; i < set.length; i++){
        var newLabel = this._processActionNode(set[i]['new']);
        var oldLabel = this._processActionNode(set[i]['old']);
        result.push({new: newLabel, old: oldLabel});
      }

      return result;
    },

    /**
     * Process the hiding of transitions for the specified definition.
     *
     * @private
     * @param {!string} defName - the definition to perform relabelling for
     */
    _processHiding: function(defName) {
      var hidden = this._definitionsMap[defName].hidden;
      if(hidden !== undefined){
        var type = hidden.type;
        var set = this._processSet(hidden.set);
        // get an array of edges in the current graph
        var edges = this._definitionsMap[defName].graph.edges;
        // check each edge to see if it needs to be updated
        edges.forEach(function(edge, index){
          var contains = _.contains(set.set, edge.label);
          if((type === 'includes' && contains) || (type === 'excludes' && !contains)){
            // only updates the edge if it needs to be hidden
            edge.isHidden = true;
          }
        }.bind(this));
      }
    },

    /**
     * Processes and returns the set of hiding objects.
     *
     * @private
     * @param {!object} set - the set of hiding objects to process
     * @returns {!object} processed set
     */
    _processSet: function(set) {
      var result = [];
      // check if set is not array
      if(set.length === undefined){
        result.push(this._processActionNode(set));
      }

      // otherwise process all the elements in the set
      else{
        for(var i = 0; i < set.length; i++){
          result.push(this._processActionNode(set[i]));
        }
      }

      return {type:"set", set:result};
    },

    /**
     *
     */
    _processRange: function(range, defName) {
      // check if range is globally defined
      if(typeof(range) === 'string'){
        if(this._rangesMap[range] !== undefined){
          return this._rangesMap[range];
        }
        else{
          throw new this.InterpreterException('');
        }
      }

      // assign constant values to start or end points if necessary
      var points = [range.start, range.end]; 

      for(var i = 0; i < points.length; i++){
        if(typeof(points[i]) === 'string'){
          var value = this._constantsMap[points[i]];
          if(value !== undefined){
            points[i] = value;
          }
          else{
            throw new this.InterpreterException('Range "' + defName + '" is refererencing undefined constant "' + value + '".');
          }
        }

        // check if simple expression
        if(points[i].type === 'simple-expression'){
          points[i] = points[i].expression.expression;
        }
      }

      // update the range
      range.start = points[0];
      range.end = points[1];

      // make sure that start of range is less than then end
      if(range.start >= range.end){
        throw new this.InterpreterException('Start of range greater than or equal to end of range for range "' + defName + '".');
      }

      range.type = 'range';
      return range;
    },
    /**
     * Relabel the nodes in each automata definition.
     * Done by performing a depth first search of the graph.
     *
     * @private
     * @param {boolean} showRefs - If set will prefix reference nodes' labels with the automaton they reference
     * @param {boolean} useIds   - If set will use the nodes' id as the label
     */
    _relabelNodes: function(showRefs, useIds) {
      for (var key in this._definitionsMap) {
        var label = 0;
        var visitedNodes = {};
        var fringe = [];
        fringe.push(this._definitionsMap[key].graph.root);
        while (fringe.length > 0) {
          var node = fringe.shift();
          // if already visited
          if (visitedNodes[node.id]) {
            continue; // don't do anything with this node and start on the next one
          }
          visitedNodes[node.id] = node;   // mark as visited
          // label the node
          var ref = node.getMetaData ('references');
          if (showRefs && ref && ref !== this.name) {
            node.label = ref + ':';
          } else {
            node.label = '';
          }
          node.label += useIds ? 'n' + node.id : label++;
          // loop through all the current node's neighbors
          var neighbors = node.neighbors;
          for (var i in neighbors) {
            // if neighbor is unvisited
            if (!visitedNodes[neighbors[i].id]) {
              fringe.push(neighbors[i]);
            }
          }
        }
      }
    },
    /**
     * Returns true if the specified process is a definition, otherwise
     * returns false.
     *
     * @private
     * @param {!object} process - the process to check
     * @returns {!boolean} true if process is definition, otherwise false
     */
    _isDefinition: function(process) {
      var definitions = ['standard', 'parallel', 'reference', 'function'];
      // check if the process type is any of the defintitions
      for(var i = 0; i < definitions.length; i++){
        var definition = definitions[i] + '-definition';
        if(process.type === definition){
          return true;
        }
      }

      // no matches found
      return false;
    },
    /**
     * Returns true if the specified name is valid, otherwise returns false.
     * A valid name is one that has not been previously defined.
     *
     * @private
     * @param {!string} name - the name to be checked
     * @returns {!boolean} true if name is valid, otherwise false
     */
    _isValidName: function(name) {
      var maps = [{name: 'definition', map: this._definitionsMap}, 
                  {name: 'constant', map: this._constantsMap}, 
                  {name: 'range', map: this._rangesMap}]
      // check all maps to see if name has been defined in any of them
      for(var i = 0; i < maps.length; i++){
        if(maps[i].map[name] !== undefined){
          return false;
        }
      }

      return true;
    },
    /**
     * Returns the next free index in the operations map.
     *
     * @private
     * @returns {!integer} - next available index
     */
    _nextOperationsIndex: function() {
      var index = this._operationsIndex;
      this._set_operationsIndex(index + 1);
      return index;
    },
    /**
     * Returns the next unique operation uid.
     *
     * @private
     * @returns {!string} - next operation uid
     */
    _nextOperationUid: function() {
      var next = this._operationUid;
      this._set_operationUid(next + 1);
      return '' + next;
    },
    /**
     * Pushes the specified definition name to the composite stack.
     *
     * @private
     * @param {!string} name - definition name
     */
    _pushToCompositeStack: function(name) {
      var stack = this._compositeStack;
      stack.push(name);
      this._set_compositeStack(stack);
    },
    /**
     * Pops the next definition name from composite stack.
     *
     * @private
     * @returns {!string} the last definition name added to the composite stack
     */
    _popFromCompositeStack: function() {
      var stack = this._compositeStack;
      var name = stack.pop();
      this._set_compositeStack(stack);
      return name;
    },
    /**
     * Builds an object containing the results of the parsing. This includes taking 
     * all the automaton definitions that are defined as visible and construct an 
     * array of automata, as well as taking all the operations parsed and constructing
     * an array of the outcomes.
     *
     * @private
     * @returns {!Automaton[]} Automata
     */
    _buildParsingResults: function() {
      var automata = [];
      var operations = {operations: [], positions: []};
      // only build parsing results if live build has been selected
      if(this._buildAutomata){
        // build automata array
        for (var key in this._definitionsMap) {
          // only display automata which are defined as visible
          if(this._definitionsMap[key].isVisible){
            automata.unshift(new Automaton(key, this._definitionsMap[key].graph));
          }
        }

        // build operations array
        var pass = 0;
        var fail = 0;
        for(var i in this._operationsMap){
          var input = this._operationsMap[i].input;

          // remove unnecessary line breaks and whitespace from input
          input = input.replace(/ /g, '\n');
          var split = input.split('\n');
          input = '';
          for(var j = 0; j < split.length; j++){
            if(split[j] !== ''){
              input += split[j];
            }
          }
          // remove the dot from input
          input = input.slice(0, input.length - 1);

          var result = this._operationsMap[i].result;
          var position = this._operationsMap[i].position;
          
          operations.operations.push(input + ' = ' + result);
          operations.positions.push(position);
          if(result){
            pass++;
          }
          else{
            fail++;
          }
        }

        // if there are no operations do not print the total numbe of operations
        if(operations.operations.length > 0){
          var results = 'Total Operations: ' + (pass + fail) +' (Pass: ' + pass + ', Fail: ' + fail + ')';
          operations.operations.unshift(results);
        }
      }
      return {automata: automata, operations: operations};
    }
  });
})();
</script>