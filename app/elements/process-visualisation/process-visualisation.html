<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../imports/dagre-d3.html">
<link rel="import" href="../imports/element-resizer.html">

<dom-module id="process-visualisation">
  <style>
    :host {
      display: block;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
      color: #6C7A89;
    }
    #svg-parent{
      @apply(--layout-fit);
      margin: 4px 4px 4px 4px;
    }
    #svg{
      width: 100%;
      height: 100%;
    }
    #name{
      position: absolute;
      top: 4px;
      left: 8px;
      color: red;
      font-size: 12pt;
      @apply(--automata-visualisation-name-style);
    }
    /*.edgePath defs marker path{
  fill: #8F939E;
}*/
  </style>
  <template>
    <div id="svg-parent">
    </div>
    <div id="name">[[name]]</div>
  </template>
</dom-module>
<script>


  (function() {
    'use strict';
    Polymer({
      is: 'process-visualisation',

      properties: {
        /**
         * The name of the automata.
         */
        name: {
          type: String,
          value: ''
        },

        graph: {
          type: Object,
          value: {}
        }
      },

      ready: function(){
        this.jgraph = new joint.dia.Graph();
        this.paper = new joint.dia.Paper({
          el: this.$['svg-parent'],
          width: 2000,
          height: 2000,
          gridSize: 1,
          model: this.jgraph
        });
        var paper = this.paper;
        var dragStartPosition;
        paper.on('blank:pointerdown',
          function(event, x, y) {
            var scale = V(paper.viewport).scale();
            dragStartPosition = { x: x * scale.sx, y: y * scale.sy};
          }
        );
        paper.on('cell:pointerup blank:pointerup', function(cellView, x, y) {
          dragStartPosition = undefined;
        });
        $(paper.el.parentElement).mousemove(function(event) {
//            console.log(this.dragStartPosition);
          if (dragStartPosition !== undefined)
            paper.setOrigin(
              event.offsetX - dragStartPosition.x,
              event.offsetY - dragStartPosition.y);
        });
        this.paper.$el.on('mousewheel DOMMouseScroll', function onMouseWheel(e) {
          //function onMouseWheel(e){
          e.preventDefault();
          e = e.originalEvent;

          var delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))) / 50;
          var offsetX = (e.offsetX || e.clientX - $(this).offset().left);

          var offsetY = (e.offsetY || e.clientY - $(this).offset().top);
          var p = offsetToLocalPoint(offsetX, offsetY);
          var newScale = V(paper.viewport).scale().sx + delta;
          if (newScale < 1) return;
          var origx = paper.options.origin.x;
          var origy = paper.options.origin.y;
          if (newScale > 0.4 && newScale < 2) {
            paper.setOrigin(0, 0);
            paper.scale(newScale, newScale, p.x, p.y);
            paper.setOrigin(origx, origy);
          }
        });

        function offsetToLocalPoint(x, y) {
          var svgPoint = paper.svg.createSVGPoint();
          svgPoint.x = x;
          svgPoint.y = y;

          return svgPoint.matrixTransform(paper.viewport.getCTM().inverse());
        }
        //Modify the transition element to place the label inside and not above.
        joint.shapes.pn.Transition = joint.shapes.basic.Generic.extend({

          markup: '<g class="rotatable"><g class="scalable"><rect class="root"/></g></g><text class="label"/>',

          defaults: _.defaultsDeep({

            type: 'pn.Transition',
            size: { width: 20, height: 60 },
            attrs: {
              'rect': {
                width: 12,
                height: 50,
                fill: '#000000',
                stroke: '#000000'
              },
              '.label': {
                'text-anchor': 'middle',
                'ref-x': .5,
                'ref-y': 23,
                ref: 'rect',
                fill: '#FFFFFF',
                'font-size': 12
              }
            }

          }, joint.shapes.basic.Generic.prototype.defaults)
        });


        var resizeElement = this;

        addResizeListener(resizeElement, function() {
          this.debounce('process-visualisation-resizer', function() {

            var svg = d3.select(this.$.svg),
              svgGroup = svg.select('g'),
              automata = this.graph;

          }, 300);
        });
      },

      setHighlightNodeId: function(id) {
        this._highlightedNodeId = id;
        Polymer.dom(this.$.svg).querySelectorAll('.highlighted').forEach(function(n){
          n.classList.remove('highlighted');
        });
        Polymer.dom(this.$.svg).querySelector('.n'+id).classList.add('highlighted');
      },
      /**
       * Redraw the automata.
       */
      redraw: function() {
        if (this.paper === undefined) return;
        this.jgraph.clear();
        this.graphMap = {};
        var lthis = this;
        if (!app.get("automata.values")) return;
        app.get("automata.values").forEach(function(graph) {
          if (!graph.graph.type) return;
          if (graph.graph.type == 'automata') {
            lthis._visualizeAutomata(graph.graph,graph.name);
          }
          if (graph.graph.type == 'petrinet') {
            lthis._visualizePetriNet(graph.graph,graph.name);
          }
        });

        joint.layout.DirectedGraph.layout(this.jgraph, {rankDir:'LR'});
        var jgraph = this.jgraph;
        var graphMap = this.graphMap;
        var i = 0;
        var paperWidth = this.paper.$el.width();
        Object.keys(graphMap).forEach(function (key) {
          var nodes = _.values(graphMap[key]);
          var lx = 9999, ly = 9999, ux = 0, uy = 0;
          for (var node in nodes) {
            var pos = nodes[node].position();
            lx = Math.min(lx,pos.x);
            ly = Math.min(ly,pos.y);
            ux = Math.max(lx,pos.x);
            uy = Math.max(ly,pos.y);
          }
          var width = ux-lx;
          var height = uy-ly;
          if (width < paperWidth) {
            var offsetX = (lthis.paper.$el.width()-width)/2;
            for (var node in nodes) {
              var pos = nodes[node].position();
              nodes[node].position(pos.x+offsetX,pos.y);
            }
          }
          var cell = new joint.shapes.basic.Rect ({
            size: { width: 100, height: 30 },
            position: { x:lx, y:ly},
            attrs: {
              rect: { fill: 'transparent', stroke: 'none' },
              'text': {text: app.get("automata.values")[i++].name, fill: 'red', 'font-size': 20}}
          });
          jgraph.addCell(cell);
          graphMap[key]['label'] = cell;
        });
        this.automata = this.graph;
        this.fire('process-visualisation-rendered');
      },_automataLink: function(source, target, label) {
        var cell = new joint.shapes.fsa.Arrow({
          source: { id: source.id },
          target: { id: target.id },
          labels: [{ position: 0.5, attrs: { text: { text: label || '', 'font-weight': 'bold' } } }],
          vertices: []
        });
        this.jgraph.addCell(cell);
        return cell;
      }, _petrinetLink : function(from, to, label) {
        var link = new joint.shapes.pn.Link({
          source: {id: nodeMap[from].id, selector: '.root'},
          target: {id: nodeMap[to].id, selector: '.root'},
          attrs: {
            text : { text: label||'' },
            '.label': {text: label||'', fill: '#7c68fc'},
            '.connection': {
              'fill': 'none',
              'stroke-linejoin': 'round',
              'stroke-width': '2',
              'stroke': '#4b4a67'
            }
          }
        });
        this.jgraph.addCell(link);
        return link;
      },_visualizeAutomata: function(process, name) {
        // add nodes in automaton to the graph
        var nodes = process.nodes;
        var nodeMap = {};
        this.graphMap[name] = nodeMap;
        nodeMap.start = new joint.shapes.fsa.StartState();
        this.jgraph.addCell(nodeMap.start);
        for(var i = 0; i < nodes.length; i++){
          if(nodes[i].getMetaData('isTerminal') !== undefined){
            nodeMap['n' + nodes[i].id] = new joint.shapes.fsa.EndState();
            this.jgraph.addCell(nodeMap['n' + nodes[i].id]);
            continue;
          }
          // add node to graph
          nodeMap['n' + nodes[i].id] = new joint.shapes.fsa.State({
            size: { width: 60, height: 60 },
            attrs: { text : { text: nodes[i].metaData.label }}
          });
          this.jgraph.addCell(nodeMap['n' + nodes[i].id]);
          // check if current node is the root node
          if(nodes[i].getMetaData('startNode')){
            this._automataLink(nodeMap.start,nodeMap['n' + nodes[i].id]);
          }
        }

        // add the edges between the nodes in the automaton to the graph
        var edges = process.edges;
        for(var i = 0; i < edges.length; i++){
          var label = edges[i].label;
          var from = 'n' + edges[i].from;
          var to = 'n' + edges[i].to;
          this._automataLink(nodeMap[from],nodeMap[to], label);
        }
      },_visualizePetriNet: function(process, name) {
        // add places in petri net to the graph
        var startPlaces = [];
        var nodeMap = {};
        this.graphMap[name] = nodeMap;
        var places = process.places;
        for(var i = 0; i < places.length; i++){
          var styleClasses = 'p' + places[i].id;
          var label = '';
          // add to array of start places if necessary
          if(places[i].metaData.startPlace !== undefined){
            label = places[i].label;
          }
          var cell = new joint.shapes.pn.Place({
            size: { width: 60, height: 60 },
            attrs: {
              '.label': {text: label, fill: '#7c68fc'}}
          });
          this.jgraph.addCell(cell);
          nodeMap['p' + places[i].id] = cell;
        }

        // add transitions to the graph
        var edgeId = 0;
        var transitions = process.transitions;
        for(var i = 0; i < transitions.length; i++){
          nodeMap['t' + transitions[i].id] = new joint.shapes.pn.Transition({
            attrs: { text : { text: transitions[i].label }}
          });
          this.jgraph.addCell(nodeMap['t' + transitions[i].id]);
          var outgoing = transitions[i].outgoingPlaces;
          for(var j = 0; j < outgoing.length; j++){
            var from = 't' + transitions[i].id;
            var to = 'p' + outgoing[j];
            this._automataLink(nodeMap[from],nodeMap[to],'');
          }

          var incoming = transitions[i].incomingPlaces;
          for(var j = 0; j < incoming.length; j++){
            var from = 'p' + incoming[j];
            var to = 't' + transitions[i].id;
            this._automataLink(nodeMap[from],nodeMap[to],'');
          }
        }
      }
    });
  })();
</script>
