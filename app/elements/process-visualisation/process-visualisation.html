<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../imports/dagre-d3.html">
<link rel="import" href="../imports/element-resizer.html">
<style>
  /*The below css disables line tools so that you can't accidentally remove or add a line
    to a state.*/
  .marker-arrowheads { display: none }
  .link-tools .tool-remove { display: none }
  .link-tools .tool-options { display: none }
  .link .mark-errors { display: none; }
  .connection { fill: transparent; }
  .connection-wrap { fill: transparent; }
</style>
<dom-module id="process-visualisation">
  <template>
    <div id="svg-parent">
    </div>
    <div id="name">[[name]]</div>
  </template>
</dom-module>
<script>
  (function() {
    'use strict';
    Polymer({
      is: 'process-visualisation',

      properties: {
        /**
         * The name of the automata.
         */
        name: {
          type: String,
          value: ''
        },

        graph: {
          type: Object,
          value: {}
        }
      },
      ready: function(){
        const _this = this;
        this.jgraph = new joint.dia.Graph();
        //Create a paper element, pointing to #svg-parent, with restrictions on moving elements out of bounds
        this.paper = new joint.dia.Paper({
          el: this.$['svg-parent'],
          gridSize: 1,
          model: this.jgraph,
          restrictTranslate: true
        });
        const paper = this.paper;
        //Process selector listener
        document.addEventListener('change-process', function(e){
          //If we are currently rendering, ignore any events
          if (_this.rendering) return;
          //When we swap, its much easier to just restore then explode again.
          if (this.exploded) {
            _this.fire('explode',false);
            _this.fire('explode',true);
            return;
          }
          //Find the bounding box of the selected processes parent, and scroll to it
          //The scroll bar is inside .process-display
          const nodeBBox = _this.graphMap[e.detail.id].parentNode.getBBox();
          const scale = V(paper.viewport).scale();
          $(".process-display").stop().animate({scrollTop:nodeBBox.origin().y*scale.sx}, '100', 'swing');
        });
        //Keep a copy of the last set options, so that when we revert from an explosion we are back
        //at the previous transformation
        let lastOptions;
        document.addEventListener('explode', function(e){
          const processDisplay = $(".process-display");
          _this.exploded = e.detail;
          const paperWidth = _this.paper.$el.width();
          const paperHeight = _this.paper.$el.height();
          const paperScale = V(paper.viewport).scale();
          Object.keys(_this.graphMap).forEach(function (key) {
            const parentNode = _this.graphMap[key].parentNode;
            const nodes = _.values(_this.graphMap[key].map);
            const parentWidth = parentNode.getBBox().width;
            const parentHeight = parentNode.getBBox().height;
            let minX = parentNode.getBBox().origin().x;
            let minY = parentNode.getBBox().origin().y;
            const scaleX = paperWidth / parentWidth;
            const scaleY = paperHeight / parentHeight;
            if (_this.exploded) {
              //Hide the parent node so we don't see a box around the element
              get$Cell(parentNode).hide();
              if (key == app.$.selector.getSelected()) {
                lastOptions = {
                  scrollTop: processDisplay.scrollTop(),
                  x: paper.options.origin.x,
                  y: paper.options.origin.y,
                  sx: paperScale.sx,
                  sy: paperScale.sy
                };
                paper.setOrigin(0, 0);
                paper.scale(Math.min(scaleX, scaleY), Math.min(scaleX, scaleY), 0, 0);
                processDisplay.scrollTop(0);
                _this.paper.setDimensions(paperWidth, parentHeight * Math.min(scaleX, scaleY));
                parentNode.translate(-minX,-minY);
                parentNode.minX = minX;
                parentNode.minY = minY;
              }
            } else {
              //Show the element that was hidden above
              get$Cell(parentNode).show();
              paper.scale(lastOptions.sx, lastOptions.sy, 0, 0);
              paper.setOrigin(lastOptions.x, lastOptions.y);
              processDisplay.scrollTop(lastOptions.scrollTop);
              if (key == app.$.selector.getSelected()) {
                parentNode.translate(parentNode.minX, parentNode.minY);
              }
              _this.rescale();
            }
          });
        });
        //Scroll listener
        this.paper.$el.on('mousewheel DOMMouseScroll', function onMouseWheel(e) {
            //Disable scrolling
          e.preventDefault();
          e = e.originalEvent;
          const delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))) / 50;
          const newScale = V(paper.viewport).scale().sx + delta;
          if (newScale > 0.4 && newScale < 2) {
              //Zoom in and out with scroll
            paper.scale(newScale, newScale, 0, 0);
          }
          _this.rescale();
        });
        this.paper.on('cell:pointerdown', function(cell) {
          if (_this.exploded || _this.rendering) {
            return;
          }
          _this.rendering = true;
          cell = cell.model;
          const parentId = cell.get('parent');
          if (parentId) {
            cell = _this.jgraph.getCell(parentId);
          }
          if (cell.index !== undefined) {
            $("#process-name-selector")[0].contentElement.selected = cell.index;
          }

          _this.rendering = false;
        });
        this.jgraph.on('change:position', function(cell) {
          //Exploded diagrams are limited by changing the dimensions of the paper
          if (_this.exploded || _this.rendering) {
            return;
          }
          const parentId = cell.get('parent');
          if (!parentId) return;
          _.each(_this.jgraph.getConnectedLinks(cell),function(link) {
            link.unset('vertices');
          });
          const parent = _this.jgraph.getCell(parentId);

          const parentBbox = parent.getBBox();
          const cellBbox = cell.getBBox();
          const changeX = Math.abs(cell.get("position").x - cell.previous('position').x);
          const changeY = Math.abs(cell.get("position").y - cell.previous('position').y);
          const size = parent.get("size");
          if (cellBbox.origin().x < parentBbox.origin().x) {
            parent.resize(size.width+changeX,size.height,{direction: "left"});
          } else if (cellBbox.corner().x > parentBbox.corner().x) {
            parent.resize(size.width+changeX,size.height,{direction: "right"})
          }
          if (cellBbox.origin().y < parentBbox.origin().y) {
            parent.resize(size.width,size.height+changeY,{direction: "top"});
          } else if (cellBbox.corner().y > parentBbox.corner().y) {
            parent.resize(size.width,size.height+changeY,{direction: "bottom"});
          }
        });
      },
      /**
       * Redraw the automata.
       */
      redraw: function() {
        if (this.paper === undefined) return;
        this.paper.setDimensions(this.paper.$el.width(),999999);
        this.jgraph.clear();
        this.graphMap = {};
        const _this = this;
        this.rendering = true;
        if (!app.get("automata.values") || app.get("automata.values").length == 0) return;
        let unknownProcess = true;
        //Scan through all graphs, checking if the currently selected graph exists
        app.get("automata.values").forEach(function(graph) {
          if (graph.id == app.$.selector.getSelected()) {
            unknownProcess = false;
          }
        });
        //It does not exist, deselect it.
        if (unknownProcess) {
          $("#process-name-selector")[0].contentElement.selected = null;
          app.$.selector._hasSelection = true;
        }
        //Convert each process to its respective graph
        _.each(app.get("automata.values"),function(graph,i){
          if (!graph.type) return;
          if (graph.type == 'automata') {
            _this._visualizeAutomata(graph,graph.id,i++);
          }
          if (graph.type == 'petrinet') {
            _this._visualizePetriNet(graph,graph.id,i++);
          }
        });
        //Pass this through to dagre to get everything laid out
        joint.layout.DirectedGraph.layout(this.jgraph, {rankDir:'LR',setLinkVertices: true});
        const jgraph = this.jgraph;
        const graphMap = this.graphMap;
        //Add some space between the elements
        let offsetY = 0;
        Object.keys(graphMap).forEach(function (key) {
          const nodes = _.values(graphMap[key].map);
          const links = [];
          //Loop through all nodes and vertices and work out the bounds of the parent
          let lx = Number.MAX_VALUE, ly = Number.MAX_VALUE, ux = 0, uy = 0;
          nodes.forEach(function (node) {
            _this.jgraph.getConnectedLinks(node).forEach(function (link) {
              links.push(link);
              link.get('vertices').forEach(function (vertex){
                lx = Math.min(lx,vertex.x);
                ly = Math.min(ly,vertex.y);
                ux = Math.max(ux,vertex.x);
                uy = Math.max(uy,vertex.y);
              });
            });
            const bbox = node.getBBox();
            lx = Math.min(lx,bbox.origin().x);
            ly = Math.min(ly,bbox.origin().y);
            ux = Math.max(ux,bbox.corner().x);
            uy = Math.max(uy,bbox.corner().y);
          });
          const width = ux - lx;
          const height = uy - ly;
          //Work out how to center smaller parents
          let offsetX = (_this.paper.$el.width() - width) / 2;
          //If the parent is larger than the screen, dont center it
          if (width+100 > _this.paper.$el.width()) offsetX = 0;
          const cell = new joint.shapes.basic.Rect({
            size: {width: 100, height: 30},
            position: {x: lx - 50, y: ly - 50},
            attrs: {
              rect: {fill: 'transparent', stroke: 'none'},
              'text': {text: key, fill: 'red', 'font-size': 20}
            }
          });

          graphMap[key].parentNode.embed(cell);

          jgraph.addCell(cell);
          graphMap[key].parentNode.resize(width+100,height+100);
          //Move the parent node without moving its children, to add a padding around it
          graphMap[key].parentNode.position(lx-50,ly-50);
          //Now move the parent node and its components back by the padding
          graphMap[key].parentNode.translate(50, 50);
          //Move the component back to the origin with a bit of padding
          graphMap[key].parentNode.translate(50, -ly+50);
          //Center smaller components, and place all components in the right place in order
          //We need to do it this way as dagre kills the ordering, so its easier to just
          //work out new y values
          graphMap[key].parentNode.translate(offsetX, offsetY);

          graphMap[key].map['label'] = cell;
          offsetY+=height+150;
        });
        this.automata = this.graphMap;
        this.fire('process-visualisation-rendered');
        this.rescale();
        this.rendering = false;
      }, _link: function(source, target, label, parentNode) {
        const cell = new joint.shapes.fsa.Arrow({
          source: {id: source.id},
          target: {id: target.id},
          labels: [{position: 0.5, attrs: {text: {text: label || '', 'font-weight': 'bold'}}}],
          smooth: false,
          attrs: {
            //Add a slight transparency, so that you can see the links behind
            'rect': {fill: 'rgba(255, 255, 255, 0.3)'}
          }
        });
        parentNode.embed(cell);
        this.jgraph.addCell(cell);
        return cell;
      },_visualizeAutomata: function(process, name, idx) {
        // add nodes in automaton to the graph
        const nodes = process.nodes;
        const nodeMap = {};
        const parentNode = new joint.shapes.parent();
        parentNode.name = name;
        parentNode.index = idx;
        this.jgraph.addCell(parentNode);
        this.graphMap[name] = {map:nodeMap,name:name,height:0,parentNode:parentNode};
        for(let i = 0; i < nodes.length; i++){
          if(nodes[i].getMetaData('isTerminal') !== undefined){
            let fill = 'green';
            if (nodes[i].getMetaData('isTerminal') === 'error') {
              fill = 'red';
            }
            nodeMap['n' + nodes[i].id] = new joint.shapes.fsa.EndState({
              attrs: { text : { text: nodes[i].metaData.label}, '.outer': {'fill':fill} }
            });
            parentNode.embed(nodeMap['n' + nodes[i].id]);
            this.jgraph.addCell(nodeMap['n' + nodes[i].id]);
            continue;
          }
          let fill = 'lightblue';
          // check if current node is the root node
          if(nodes[i].getMetaData('startNode')){
            fill='red';
          }
          // add node to graph
          nodeMap['n' + nodes[i].id] = new joint.shapes.fsa.State({
            size: { width: 60, height: 60 },
            attrs: { text : { text: nodes[i].metaData.label}, circle: {'fill':fill} }
          });
          parentNode.embed(nodeMap['n' + nodes[i].id]);
          this.jgraph.addCell(nodeMap['n' + nodes[i].id]);
        }

        // add the edges between the nodes in the automaton to the graph
        const edges = process.edges;
        for(let i = 0; i < edges.length; i++){
          let label = edges[i].label;
          const from = 'n' + edges[i].from;
          const to = 'n' + edges[i].to;
          if(edges[i].getMetaData('guard') !== undefined){
            label =edges[i].getMetaData('guard')+"\n"+label;
            const vars = edges[i].getMetaData('guardVariables');
            for (let v = 1; v<vars.length; v++) {
              label = vars[v].name+"="+vars[v].value + "\n" + label;
            }
          }
          this._link(nodeMap[from],nodeMap[to], label,parentNode);
        }
      },_visualizePetriNet: function(process, name, idx) {
        const nodeMap = {};
        const parentNode = new joint.shapes.parent();
        parentNode.index = idx;
        parentNode.name = name;
        this.jgraph.addCell(parentNode);
        this.graphMap[name] = {map:nodeMap,name:name,height:0,parentNode:parentNode};
        const places = process.places;
        for(let i = 0; i < places.length; i++){
          let label = '';
          // add to array of start places if necessary
          if(places[i].metaData.startPlace !== undefined){
            label = places[i].label;
          }
          const cell = new joint.shapes.pn.Place({
            size: {width: 60, height: 60},
            attrs: {
              '.label': {text: label, fill: '#7c68fc'}
            }
          });
          parentNode.embed(cell);
          this.jgraph.addCell(cell);
          nodeMap['p' + places[i].id] = cell;
        }

        // add transitions to the graph
        const transitions = process.transitions;
        for(let i = 0; i < transitions.length; i++){
          let label = transitions[i].label;
          if(transitions[i].getMetaData('guard') !== undefined){
            label =transitions[i].getMetaData('guard')+"\n"+label;
            const vars = transitions[i].getMetaData('guardVariables');
            for (let v = 1; v<vars.length; v++) {
              label = vars[v].name+"="+vars[v].value + "\n" + label;
            }
          }
          nodeMap['t' + transitions[i].id] = new joint.shapes.pn.Transition({
            attrs: { text : { text: label }}
          });
          parentNode.embed(nodeMap['t' + transitions[i].id]);
          this.jgraph.addCell(nodeMap['t' + transitions[i].id]);
          const outgoing = transitions[i].outgoingPlaces;
          for(let j = 0; j < outgoing.length; j++){
            const from = 't' + transitions[i].id;
            const to = 'p' + outgoing[j];
            this._link(nodeMap[from],nodeMap[to],'',parentNode);
          }

          const incoming = transitions[i].incomingPlaces;
          for(let j = 0; j < incoming.length; j++){
            const from = 'p' + incoming[j];
            const to = 't' + transitions[i].id;
            this._link(nodeMap[from],nodeMap[to],'',parentNode);
          }
        }
      },
      rescale: function() {
        let screenHeight = this.paper.$el.parent().parent().height();
        let screenWidth = this.paper.$el.width();
        const scale = V(this.paper.viewport).scale();
        if (this.exploded) {
          return;
        }
        let maxX = 0;
        let maxY = 0;
        const graphs = Object.values(this.graphMap);
        graphs.forEach(function (graph) {
          maxX = Math.max(maxX,graph.parentNode.getBBox().corner().x);
          maxY = Math.max(maxY,graph.parentNode.getBBox().corner().y);
        });
        this.paper.setDimensions(Math.max(maxX*scale.sx,screenWidth),Math.max(maxY*scale.sy+200,screenHeight));
      },
    });
  })();
</script>
