<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../imports/dagre-d3.html">
<link rel="import" href="../imports/element-resizer.html">
<style>
  /*The below css disables line tools so that you can't accidentally remove or add a line
    to a state.*/
  .marker-arrowheads { display: none }
  .link-tools .tool-remove { display: none }
  .link-tools .tool-options { display: none }
  .link .mark-errors { display: none; }
  .connection { fill: transparent; }
  .connection-wrap { fill: transparent; }
</style>
<dom-module id="process-visualisation">
  <template>
    <div id="svg-parent">
    </div>
    <div id="name">[[name]]</div>
  </template>
</dom-module>
<script>
  (function() {
    'use strict';
    Polymer({
      is: 'process-visualisation',

      properties: {
        /**
         * The name of the automata.
         */
        name: {
          type: String,
          value: ''
        },

        graph: {
          type: Object,
          value: {}
        }
      },
      ready: function(){
        this.displayedGraphs = {};
        const _this = this;
        this.graphMap = {};
        this.jgraph = new joint.dia.Graph();
        //Create a paper element, pointing to #svg-parent, with restrictions on moving elements out of bounds
        this.paper = new joint.dia.Paper({
          el: this.$['svg-parent'],
          gridSize: 1,
          model: this.jgraph,
          restrictTranslate: true
        });
        const paper = this.paper;
        //Process selector listener
        document.addEventListener('change-process', function(e){
          //If we are currently rendering, ignore any events
          if (_this.rendering) return;
          //When we swap, its much easier to just restore then explode again.
          if (_this.exploded) {
            _this.fire('explode',false);
            _this.fire('explode',true);
            return;
          }
          //Find the bounding box of the selected processes parent, and scroll to it
          //The scroll bar is inside .process-display
          const nodeBBox = _this.displayedGraphs[e.detail.id].getBBox();
          const scale = V(paper.viewport).scale();
          $(".process-display").stop().animate({scrollTop:nodeBBox.origin().y*scale.sy}, '100', 'swing');
        });
        document.addEventListener('addProcess', function(e){
          //If we are currently rendering, ignore any events
          if (_this.rendering) return;
          _this.addGraph(app.$.selector.getSelectedName());
        });
        document.addEventListener('clearProcess',function(e) {
          //If we are currently rendering, ignore any events
          if (_this.rendering) return;
          //Reset the explosion status since the last exploded item is now gone
          app.$.selector._explosionLabel = "Explode to process";
          if (_this.exploded)
            _this.fire('explode',false);
          _this.displayedGraphs = {};
          $("#process-display-selector")[0].contentElement.selected = null;
          app.$.selector._hasSelection = false;
          app.splice('automata.display', 0, app.get('automata.display').length);
          _this.jgraph.resetCells();
        })
        document.addEventListener('addAll', function(){
          //If we are currently rendering, ignore any events
          if (_this.rendering) return;
          _.each(app.get("automata.values"),graph => _this.addGraph(graph.id));
        });
        document.addEventListener('removeProcess', function(){
          //If we are currently rendering, ignore any events
          if (_this.rendering) return;
          //Reset the explosion status since the last exploded item is now gone
          app.$.selector._explosionLabel = "Explode to process";
          if (_this.exploded)
            _this.fire('explode',false);
          const name = app.$.selector.getSelected();
          const dispSelector =  $("#process-display-selector")[0].contentElement;
          let graph = _this.displayedGraphs[app.$.selector.getSelected()];
          let index = dispSelector.selected;
          dispSelector.selected = null;
          app.$.selector._hasSelection = false;
          app.splice('automata.display',index,1);
          //Remove children
          _this.jgraph.removeCells(graph.getEmbeddedCells());
          //Remove parent
          _this.jgraph.removeCells([graph]);
          delete _this.displayedGraphs[name];
        });
        //Keep a copy of the last set options, so that when we revert from an explosion we are back
        //at the previous transformation
        let lastOptions;
        document.addEventListener('explode', function(e){
          const processDisplay = $(".process-display");
          _this.exploded = e.detail;
          const paperWidth = _this.paper.$el.width();
          const paperHeight = _this.paper.$el.height();
          _.each(_this.displayedGraphs,function (parentNode, key) {
            const {x: minX, y: minY} = parentNode.getBBox().origin();
            const {width,height} = parentNode.getBBox();
            const scaleX = paperWidth / width;
            const scaleY = paperHeight / height;
            if (_this.exploded) {
              //Hide the parent node so we don't see a box around the element
              get$Cell(parentNode).hide();
              if (key == app.$.selector.getSelected()) {
                lastOptions = {
                  scrollTop: processDisplay.scrollTop(),
                  origin: paper.options.origin,
                  scale: V(paper.viewport).scale(),
                  key: key
                };
                paper.setOrigin(0, 0);
                paper.scale(Math.min(scaleX, scaleY), Math.min(scaleX, scaleY), 0, 0);
                processDisplay.scrollTop(0);
                _this.paper.setDimensions(paperWidth, height * Math.min(scaleX, scaleY));
                parentNode.translate(-minX,-minY);
                parentNode.minX = minX;
                parentNode.minY = minY;
              } else {
                _.each(collectDeepEmbedded(parentNode),node => get$Cell(node).hide());
              }
            } else {
              //Show the element that was hidden above
              get$Cell(parentNode).show();
              if (key == lastOptions.key) {
                paper.scale(lastOptions.scale.sx, lastOptions.scale.sy, 0, 0);
                paper.setOrigin(lastOptions.origin.x, lastOptions.origin.y);
                processDisplay.scrollTop(lastOptions.scrollTop);
                parentNode.translate(parentNode.minX, parentNode.minY);
              }
              _.each(collectDeepEmbedded(parentNode),node => get$Cell(node).show());
              _this.rescale();
            }
          });
          //We might have hidden interrupted states, so lets show them
          _.each(collectDeepEmbedded(_this.displayedGraphs[app.$.selector.getSelected()]),cell=>get$Cell(cell).show());
        });
        //Scroll listener
        this.paper.$el.on('mousewheel DOMMouseScroll', function onMouseWheel(e) {
          //Disable scrolling
          e.preventDefault();
          e = e.originalEvent;
          const delta = Math.max(-1, Math.min(1, (e.wheelDelta || -e.detail))) / 50;
          const newScale = V(paper.viewport).scale().sx + delta;
          if (newScale > 0.4 && newScale < 2) {
            //Zoom in and out with scroll
            paper.scale(newScale, newScale, 0, 0);
          }
          _this.rescale();
        });
        this.paper.on('cell:pointerdown', function(cell) {
          if (_this.exploded || _this.rendering) {
            return;
          }
          _this.rendering = true;
          cell = cell.model;
          const parentId = cell.get('parent');
          if (parentId && cell.attributes.type!=='parentNode'&& cell.attributes.type!=='box') {
            cell = _this.jgraph.getCell(parentId);
          }
          let disp = app.get("automata.display");
          for (let i = 0; i < disp.length; i++) {
            if (disp[i].parentNode === cell) {
              $("#process-display-selector")[0].contentElement.selected = i;
            }
          }
          _this.rendering = false;
        });
        this.paper.on('cell:pointermove', function(cell) {
          cell = cell.model;
          const parentId = cell.get('parent');
          if (!parentId) return;
          adjustVertices(_this.jgraph,cell);
        });
        this.jgraph.on('change:position', function(cell) {
          //Exploded diagrams are limited by changing the dimensions of the paper
          if (_this.exploded || _this.rendering) {
            return;
          }
          const parentId = cell.get('parent');
          if (!parentId) return;
          const parent = _this.jgraph.getCell(parentId);

          const parentBbox = parent.getBBox();
          const cellBbox = cell.getBBox();
          const changeX = Math.abs(cell.get("position").x - cell.previous('position').x);
          const changeY = Math.abs(cell.get("position").y - cell.previous('position').y);
          const size = parent.get("size");
          if (cellBbox.origin().x < parentBbox.origin().x) {
            parent.resize(size.width+changeX,size.height,{direction: "left"});
          } else if (cellBbox.corner().x > parentBbox.corner().x) {
            parent.resize(size.width+changeX,size.height,{direction: "right"})
          }
          if (cellBbox.origin().y < parentBbox.origin().y) {
            parent.resize(size.width,size.height+changeY,{direction: "top"});
          } else if (cellBbox.corner().y > parentBbox.corner().y) {
            parent.resize(size.width,size.height+changeY,{direction: "bottom"});
          }
        });
      },
      addGraph: function(name) {
        this.rendering = true;
        //construct the graph first if it doesnt exist or has changed
        constructGraphs(this.graphMap,name);
        //Work out the bottom corner of the lowest element
        let maxY = 0;
        _.each(this.displayedGraphs,graph => maxY = Math.max(maxY,graph.getBBox().corner().y));
        //Find a name that isnt in use
        let oldName = name;
        let tmpIdx = 1;
        while (this.displayedGraphs[name]) {
          name = oldName+(tmpIdx++);
        }
        //Assign that name to the old label
        this.graphMap[oldName].label.attributes.attrs.text.text = name;
        //There is an undefined cell tagged on the end. My guess is its the edge???
        var embeds = this.graphMap[oldName].parentNode.get("embeds");
        if (embeds[embeds.length-1]===undefined) {
          embeds.pop();
        }
        //Clone the process into cells, also cloning all children
        let cells = this.graphMap[oldName].parentNode.clone({deep: true});
        //Sort the array, putting links after components, as the links will fail to be added if their
        //linked components do not exist
        cells.sort((a,b) => a.attributes.type==="fsa.Arrow"?1:-1);
        let graph = {};
        //All we really care about is the parent at this point
        graph.parentNode = cells[0];
        graph.id = name;
        this.displayedGraphs[name] = cells[0];
        this.jgraph.addCells(cells);
        //Note, we need to add the cells before translating the cell to its correct position
        graph.parentNode.translate(0,maxY);
        this.rescale();
        app.push("automata.display",graph);
        const _this = this;
        const directEmbeds = _.filter(cells[0].getEmbeddedCells(),cell=>cell.attributes.type=='boxLabel');
        cells.forEach(cell => {
          if (directEmbeds.indexOf(cell) !== -1) {
            return;
          }

          if (cell.attributes.type === 'embedNode') {
            get$Cell(cell).hide();
          }
          //box means interrupt
          if (cell.attributes.type === 'boxLabel') {
            const lbl = cell.attributes.attrs.text.text;
            let newLbl = lbl;
            tmpIdx = 1;
            while (this.displayedGraphs[newLbl]) {
              newLbl = lbl+(tmpIdx++);
            }
            cell.attr({ text: { text: newLbl } });
            let graph = {};
            graph.parentNode = _this.jgraph.getCell(cell.get("parent"));
            graph.id = newLbl;
            _this.displayedGraphs[graph.id] = graph.parentNode;
            app.push("automata.display",graph);
          }
        });
        $("#process-display-selector")[0].contentElement.selected = app.get("automata.display").length-1;
        //Find the bounding box of the selected processes parent, and scroll to it
        //The scroll bar is inside .process-display
        const nodeBBox = graph.parentNode.getBBox();
        const scale = V(this.paper.viewport).scale();
        $(".process-display").stop().animate({scrollTop:nodeBBox.origin().y*scale.sx}, '100', 'swing');
        this.rendering = false;
      },
      /**
       * Redraw the automata.
       */
      redraw: function() {
        if (this.paper === undefined) return;
        if (!app.get("automata.values") || app.get("automata.values").length == 0) return;
        this.automata = this.graphMap;
        this.fire('process-visualisation-rendered');
      },
      rescale: function() {
        if (this.exploded) {
          return;
        }
        let screenHeight = this.paper.$el.parent().parent().height();
        let screenWidth = this.paper.$el.width();
        const scale = V(this.paper.viewport).scale();
        let maxX = 0;
        let maxY = 0;
        _.each(this.displayedGraphs,function (graph) {
          const bbox = graph.getBBox();
          maxX = Math.max(maxX,bbox.corner().x);
          maxY = Math.max(maxY,bbox.corner().y);
        });
        this.paper.setDimensions(Math.max(maxX*scale.sx,screenWidth),Math.max(maxY*scale.sy+200,screenHeight));
      },
    });
  })();
</script>
