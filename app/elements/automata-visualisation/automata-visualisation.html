<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../imports/dagre-d3.html">

<dom-module id="automata-visualisation">
<style>
:host {
  display: block;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
  color: #6C7A89;
}
#svg{
  width: 100%;
  height: 100%;
}
.node circle,
.node rect {
  fill: var(--automata-node-fill, #E2E6E7);
  stroke: var(--automata-node-stroke, #8F939E);
  stroke-width: var(--automata-node-stroke-width, 2px);
}
.node:first-of-type circle,
.node:first-of-type rect{
  fill: var(--automata-start-node-fill, #F5B0B0);
  stroke: var(--automata-start-node-stroke);
  stroke-width: var(--automata-start-node-stroke-width);
}
.node .label {
  fill: var(--automata-node-label-color, #000000);
}
.node:first-of-type .label {
  fill: var(--automata-start-node-label-color, #000000);
}
.edgePath path {
  fill: var(--automata-edge-fill, #8F939E);
  stroke: var(--automata-edge-stroke, #8F939E);
  stroke-width: var(--automata-edge-stroke-width, 2px);
}
.edgeLabel {
  fill: var(--automata-edge-label-color, #000000);
}
/*.edgePath defs marker path{
  fill: #8F939E;
}*/
</style>
<template>
  <svg id="svg"></svg>
</template>
</dom-module>
<script>
"use strict";
(function() {
  Polymer({
    is: 'automata-visualisation',

    properties: {
      /**
      * The array of nodes to draw.
      * A node is a Object with a unquie 'id' field and a 'label' field
      */
      nodes: {
        type: Array,
        value: []
      },

      /**
      * The array of edges to draw.
      * An edge is a Object that has a 'from' and a 'to' field specifying the nodes it connects.
      * It may also have a 'label' field (if no label is given, epsilon (ε) will be used)
      */
      edges: {
        type: Array,
        value: []
      }
    },

    ready: function(){
      var $this = this;
      setTimeout(function(){
        $this.redraw();
      }, 0);
    },

    /**
    * Redraw the automata.
    */
    redraw: function(){
      // remove the child nodes (the old graph) from the svg element
      for(var i=0; i<this.$.svg.childNodes.length; i++){
        Polymer.dom(this.$.svg).removeChild(this.$.svg.childNodes[i]);
      }

      // Create a new directed graph
      var automata = new dagreD3.graphlib.Graph();
      automata.setGraph({
        // nodesep: 70,
        // ranksep: 50,
        rankdir: 'LR',
        marginx: 0,
        marginy: 0
      });

      // Automatically label each of the nodes
      this.nodes.forEach(function(node) {
        automata.setNode(node.id, { label: node.label, shape: 'circle' });
      });

      // Default to assigning a new object as a label for each new edge.
      automata.setDefaultEdgeLabel(function() {
        return {};
      });

      // Automatically set each of the edges, with:
      //  - the from node's label
      //  - the to node's label
      //  - the edge's extra data (could be label, width, height, etc.)
      this.edges.forEach(function(edge) {
        automata.setEdge(edge.from, edge.to, { label: edge.label || 'ε' });
      });

      // add a new group node to the svg element for the new graph
      var svg = d3.select(this.$.svg),
      svgGroup = svg.append('g');

      // create the renderer,
      // then run the renderer, which will draw the graph and insert it into the svgGroup.
      // Note: trying call render method with a node (first arg) that is not yet in the Dom will cause an error
      var render = new dagreD3.render();
      render(svgGroup, automata);

      // remove the svg element and then put it back in properly
      // (otherwise thing like shady dom css cannot be applied)
      Polymer.dom(this.root).appendChild(Polymer.dom(this.root).removeChild(this.$.svg));

      // Do zoom - center

      // Get the SVG's attrs as well as the automata's attrs
      var svgStyle = window.getComputedStyle(svg[0][0]),
          svgWidth = parseFloat(svgStyle.getPropertyValue('width')),
          svgHeight = parseFloat(svgStyle.getPropertyValue('height')),
          automataWidth = automata.graph().width,
          automataHeight = automata.graph().height;

      //  By default, set the scale to this value
      var defaultInitialScale = 1.5;

      // Compute the scale where the automata will fit
      var computedInitialScale = svgWidth / automataWidth;

      // Choose the scale which is smaller, such that we ensure the entire automata is viewable
      var initialScale = Math.min(defaultInitialScale, computedInitialScale);

      // limit the zoom and pan behaviour
      var zoom = d3.behavior.zoom().scaleExtent([0.5, 5]).on("zoom", function() {

          // the raw translate value [x, y] from the mouse coords
          var t = d3.event.translate;
          // set our modified scale to reflect the initial scale in addition to the user's scale changes
          var s = initialScale + d3.event.scale - 1;

          // the maximum left value
          var txl = Math.max(0, Math.min(svgWidth - automata.graph().width * s, t[0]));
          // the maximum right value
          var txr = Math.min(svgWidth - automata.graph().width * s , Math.max(0, t[0]));
          // the ultimate x value, souch that it is bounded to txl and txr
          var tx = Math.min(txl, Math.max(txr, t[0]));

          // the maximum top value
          var tyl = Math.max(0, Math.min(svgHeight - automata.graph().height * s, t[1]));
          // the maximum bottom value
          var tyr = Math.min(svgHeight - automata.graph().height * s , Math.max(0, t[1]));
          // the ultimate y value, souch that it is bounded to txl and txr
          var ty = Math.min(tyl, Math.max(tyr, t[1]));

          // the ultimate translation array, bounded
          var boundedTranslate = [tx, ty];

          //scale and translate
          svgGroup.attr("transform", "translate(" + boundedTranslate[0] + "," + boundedTranslate[1] + ")" +
                                      "scale(" + s + ")");
        });
      // Update the svg such that it's events call our bounding function
      svg.call(zoom);

      // Calculate the offsets required to be in center
      var xCenterOffset = (svgWidth - automata.graph().width * initialScale) / 2;
      var yCenterOffset = (svgHeight - automata.graph().height * initialScale) / 2;

      // Center the graph
      zoom.translate([ xCenterOffset, yCenterOffset]).event(svg);

    }

  });
})();
</script>
