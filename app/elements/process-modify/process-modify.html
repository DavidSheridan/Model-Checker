<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../imports/element-resizer.html">

<dom-module id="process-modify">
  <template>
    <div style="">
      <paper-dropdown-menu id="process-selector" label="Process" on-iron-select="_onSelection" disabled$="{{!_hasProcesses}}">
        <paper-menu class="dropdown-content">
          <template is="dom-repeat" items="{{processes}}">
            <paper-item data-automaton-name="{{item.id}}">{{item.id}}</paper-item>
          </template>
          <paper-listbox class="dropdown-content" selected$="{{!_hasSelection}}"></paper-listbox>
        </paper-menu>
      </paper-dropdown-menu>
      <paper-button on-tap="addGraph" disabled$="{{!_hasSelection}}">Add Process</paper-button>
      <div id="svg-parent2"></div>
    </div>
  </template>
</dom-module>
<script>
  (function() {
    'use strict';
    Polymer({
      is: 'process-modify',
      properties: {

        /**
         * The automata available to walk.
         */
        processes: {
          type: Array
        },

        _hasSelection: {
          type: Boolean,
          value: false
        },
        _hasProcesses: {
          type: Boolean,
          computed: '_greaterThan(processes.length, 0)'
        },
        _initialSelection: {
          type: String,
          computed: 'initialSelection()'
        },
      },
      _initialSelection: function(){
        return "0";
      },
      /**
       * @returns {!boolean} a > b
       */
      _greaterThan: function(a, b){
        return a > b;
      },
      ready: function(){
        this.displayedGraphs = {};
        this.jgraph = new joint.dia.Graph();
        //Create a paper element, pointing to #svg-parent, with restrictions on moving elements out of bounds
        this.paper = new joint.dia.Paper({
          el: this.$['svg-parent2'],
          gridSize: 1,
          model: this.jgraph,
          restrictTranslate: true,
          async: true
        });
        const _this = this;
        this.jgraph.on('change:position', function(cell) {
          //Exploded diagrams are limited by changing the dimensions of the paper
          //Don't update the size of the parent when the interrupt updates
          if (_this.exploded || _this.rendering || cell.attributes.type === 'interruptEmbedNode') {
            return;
          }
          //If a cell is an interrupt, update the size of hte respective interrupt too
          _.each(cell.getEmbeddedCells(),node => {
            if (node.attributes.type === 'interruptEmbedNode') {
              node.set('position',cell.get('position'));
              node.set('size',cell.get('size'));
            }
          });

          const parentId = cell.get('parent');
          if (!parentId) return;
          const parent = _this.jgraph.getCell(parentId);
          let minX = Number.MAX_VALUE, minY = Number.MAX_VALUE;
          let maxX = 0,maxY=0;
          let label, buttons;
          _.each(parent.getEmbeddedCells(),node => {
            if (node.attributes.type === 'parentLabel' ||
              node.attributes.type === 'interruptLabel') {
              label = node;
              return;
            }
            if (node.attributes.type === 'buttons') {
              buttons = node;
              return;
            }
            if (node.attributes.type === 'interruptEmbedNode' ||
              node.attributes.type === 'fsa.Arrow') return;
            const bbox = node.getBBox();
            minX = Math.min(minX,bbox.origin().x);
            minY = Math.min(minY,bbox.origin().y);
            maxX = Math.max(maxX,bbox.corner().x);
            maxY = Math.max(maxY,bbox.corner().y);
          });
          let width = maxX-minX;
          let height = maxY-minY;
          width+=100;
          height+=200;
          parent.resize(width,height);
          _this.rendering = true;
          parent.set("position", {x:minX-50,y:minY-100});
          if (label)
            label.set("position", {x:minX-50,y:minY-90});
          if (buttons)
            buttons.set("position", {x:maxX-50,y:minY-90});
          _this.rendering = false;
        });

        this.paper.on('render:done', ()=> {
          app.$.selector.locked = this.rendering = false;
          if (_this.graphsToAdd.length > 0) {
            const graph = _this.graphsToAdd.pop();
            _this.addGraph(graph.name,graph.hidden);
          } else {
            app.$.console.log("Finished rendering!");
            $(".disableOnRender")[0].disabled = false;
          }
        });
        //Espand the drawing area to the size of the screen when zooming
        window.addEventListener('resize', function(){
          _this.rescale();
        });
        this.paper.on('cell:pointermove', function(cell) {
          cell = cell.model;
          const parentId = cell.get('parent');
          if (!parentId) {
            return;
          }
          adjustVertices(_this.jgraph,cell);
        });
        this.jgraph.on('change:size', function(cell) {
          //Exploded diagrams are limited by changing the dimensions of the paper
          if (_this.exploded || _this.rendering) {
            return;
          }
          //If a cell is an interrupt, update the size of hte respective interrupt too
          _.each(cell.getEmbeddedCells(), node => {
            if (node.attributes.type === 'interruptEmbedNode') {
              node.set('position', cell.get('position'));
              node.set('size', cell.get('size'));
            }
          });
        });
      },
      _onSelection: function(e, detail){
        this._hasSelection = true;
        var graph = { name:detail.item.dataAutomatonName };
        for(var i in this.display){
          if(this.display[i].id === graph.name){
            graph.graph = this.display[i].graph;
            this.fire('change-process', this.display[i]);
            break;
          }
        }

      },
      removeGraph: function(cell){
          let name = cell;
        //If we are currently rendering, ignore any events
        if (this.rendering) return;
        if (cell.id) {
          cell = this.jgraph.getCell($(cell).parent().parent().parent().attr("model-id"));
          name = cell.get("graphID");
          cell = this.jgraph.getCell(cell.get("parent"));
        } else {
            cell = this.displayedGraphs[name];
        }
        //Remove children
        this.jgraph.removeCells(cell.getEmbeddedCells());
        //Remove parent
        this.jgraph.removeCells([cell]);
        delete this.displayedGraphs[name];
      },
      rescale: function() {
        if (this.exploded) {
          return;
        }
        let screenHeight = this.paper.$el.parent().parent().height();
        let screenWidth = this.paper.$el.width();
        const scale = V(this.paper.viewport).scale();
        let maxX = 0;
        let maxY = 0;
        _.each(this.displayedGraphs,function (graph) {
          const bbox = graph.getBBox();
          maxX = Math.max(maxX,bbox.corner().x);
          maxY = Math.max(maxY,bbox.corner().y);
        });
        this.paper.setDimensions(Math.max(maxX*scale.sx,screenWidth),Math.max(maxY*scale.sy+200,screenHeight));
      },
      redraw: function() {
        $("#process-selector")[0].contentElement.selected = null;
      },

      graphsToAdd: [],
      addGraph: function() {
        let name = $("#process-selector")[0].selectedItemLabel;
        if (this.rendering) {
          this.graphsToAdd.push({name: name, hidden: false});
          return;
        }
        //Work out the bottom corner of the lowest element
        let maxY = 0;
        if (this.displayedGraphs[name]) {
            maxY = this.displayedGraphs[name].getBBox().corner().y;
          removeGraph(name);
        } else {
          _.each(this.displayedGraphs,graph => maxY = Math.max(maxY,graph.getBBox().corner().y));
        }
        $(".disableOnRender")[0].disabled = true;
        app.$.console.clear();
        app.$.console.log("Rendering: "+name);
        app.$.console.log("While rendering, you can not use the editor tab.");
        app.$.selector.locked = this.rendering = true;
        //construct the graph first if it doesnt exist or has changed
        //If the visualiser has a copy of the graph, its much easier to just use it isntead of keeping two sets.
        constructGraphs(app.$.visualiser.graphMap,name, false, ()=>{
          const alphabet = Object.keys(app.$.visualiser.graphMap[name].alphabet);
          //Clone the process into cells, also cloning all children
          let cells = app.$.visualiser.graphMap[name].parentNode.clone({deep: true});
          let graph = {};
          //We need to make sure all nodes are rendered before edges.
          cells.sort((a,b) => a.attributes.type==="fsa.Arrow"?1:-1);
          //All we really care about is the parent at this point
          graph.parentNode = cells[0];
          graph.id = name;
          this.displayedGraphs[name] = cells[0];
          this.jgraph.addCells(cells);
          var m1 = new joint.shapes.devs.Model({
            position: { x: 50, y: 50 },
            size: { width: 90, height: 90 },
            inPorts: ["test"],
            outPorts: alphabet.slice(),
            attrs: {
              '.label': { text: 'Model', 'ref-x': .5, 'ref-y': .2 },
              rect: { fill: '#2ECC71' }
            }
          });
          this.jgraph.addCell(m1);
          //Note, we need to add the cells before translating the cell to its correct position
          graph.parentNode.translate(0,maxY);
          graph.parentNode.set("graphId",graph.id);
          this.rescale();
          //Find the bounding box of the selected processes parent, and scroll to it
          //The scroll bar is inside .process-display
          const nodeBBox = graph.parentNode.getBBox();
          const scale = V(this.paper.viewport).scale();
          $(".process-modify-display").stop().animate({scrollTop:nodeBBox.origin().y*scale.sx}, '100', 'swing');
        },{disableExplode:true});
      },
    })
  })();
</script>
