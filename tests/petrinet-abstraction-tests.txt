/* PETRI NET ABSTRACTION TESTS */

// basic abstraction
petrinet {
    Basic = (a -> b -> c -> STOP)\{b}.
    AbsBasic = abs(Basic).
    EqBasic = (a -> c -> Stop | a -> c -> Stop),
        Stop = (STOP).
}

AbsBasic ~ EqBasic.

// abstract the first action
petrinet {
    Basic2 = (a -> b -> c -> STOP)\{a}.
    AbsBasic2 = abs(Basic2).
    EqBasic2 = (b -> c -> STOP).
}

AbsBasic2 ~ EqBasic2.

// abstract the last action
petrinet {
    Basic3 = (a -> b -> c -> STOP)\{c}.
    AbsBasic3 = abs(Basic3).
    EqBasic3 = (a -> (b -> STOP | b -> STOP)).
}

AbsBasic3 ~ EqBasic3.

// multiple hidden actions
petrinet {
    Multi = (a -> b -> c -> d -> STOP)\{b, c}.
    AbsMulti = abs(Multi).
    EqMulti = (a -> d -> Stop | a -> d -> Stop | a -> d -> Stop),
        Stop = (STOP).
}

AbsMulti ~ EqMulti.


// multiple hidden actions at the beginning
petrinet {
    Multi2 = (a -> b -> c -> d -> STOP)\{a, b}.
    AbsMulti2 = abs(Multi2).
    EqMulti2 = (c -> d -> STOP).
}

AbsMulti2 ~ EqMulti2.

// multiple hidden actions at the end
petrinet {
    Multi3 = (a -> b -> c -> d -> STOP)\{c, d}.
    AbsMulti3 = abs(Multi3).
    EqMulti3 = (a -> (b -> STOP | b -> STOP | b -> STOP)).
}

AbsMulti3 ~ EqMulti3.

// action hidden to form a tau loop (assumes fair abstraction)
petrinet {
    Loop = (a -> A),
        A = (x -> A)\{x}.
    AbsLoop = abs(Loop).
    EqLoop = (a -> STOP).
}

AbsLoop ~ EqLoop.

// abstract a looped process with a hidden action
petrinet {
    Loop2 = (a -> x -> Loop2)\{x}.
    AbsLoop2 = abs(Loop2).
    EqLoop2 = (a -> EqLoop2 | a -> A),
        A = (a -> A).
}

AbsLoop2 ~ EqLoop2.

// abstract a looped process with a hidden action
petrinet {
    Loop3 = (a -> b -> c -> Loop3)\{b}.
    AbsLoop3 = abs(Loop3).
    EqLoop3 = (a -> c -> EqLoop3 | a -> c -> EqLoop3).
}

AbsLoop3 ~ EqLoop3.

// abstracting a syncronised action in a concurrent process
petrinet {
    Concurrent = (a -> b -> c -> STOP || x -> b -> z -> STOP)\{b}.
    AbsConcurrent = abs(Concurrent).
    // need an equivalent petri net
}

// abstracting a single action in a concurrent process
petrinet {
    Concurrent2 = (a -> b -> c -> STOP || x -> y -> z -> STOP)\{b}.
    AbsConcurrent2 = abs(Concurrent2).
    // need equivalent petri net
}

// abstraction example from the crib sheet
petrinet {
    Example = (a -> (x -> b -> STOP | c -> STOP))\{x}.
    AbsExample = abs(Example).
    EqExample = (a -> A | a -> B),
        A = (c -> STOP | b -> Stop),
        B = (b -> Stop),
        Stop = (STOP).
}

AbsExample ~ EqExample.

// buffer example
petrinet {
    Buff = (in -> out -> Buff).
    Buff2 = (a:Buff/{x/a.out} || b:Buff/{x/b.in})\{x}.
    AbsBuff = abs(Buff2).
    // need an equivalent petri net
}